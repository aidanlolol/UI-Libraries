--[[
╭━╮╱╭╮╱╱╱╱╱╱╱╱╭╮╱╱╱╱╱╱╱╱╱╱╭━━━╮╱╭╮            |
┃┃╰╮┃┃╱╱╱╱╱╱╱╱┃┃╱╱╱╱╱╱╱╱╱╱┃╭━╮┃╱┃┃            |
┃╭╮╰╯┣━━┳╮╭┳━━┫┃╭━━┳━━┳━━╮┃┃╱┃┣━╯┣╮╭┳┳━╮     | Welcome to the Cilberion Admin source, feel free to take a look around.
┃┃╰╮┃┃╭╮┃╰╯┃┃━┫┃┃┃━┫━━┫━━┫┃╰━╯┃╭╮┃╰╯┣┫╭╮╮    | Enjoy.
┃┃╱┃┃┃╭╮┃┃┃┃┃━┫╰┫┃━╋━━┣━━┃┃╭━╮┃╰╯┃┃┃┃┃┃┃┃    |
╰╯╱╰━┻╯╰┻┻┻┻━━┻━┻━━┻━━┻━━╯╰╯╱╰┻━━┻┻┻┻┻╯╰╯    |
--]]

 -- Waits until game is loaded
 local game = game
 local GetService = game.GetService
 if (not game.IsLoaded(game)) then
	 local Loaded = game.Loaded
	 Loaded.Wait(Loaded);
	 wait(1.5)
 end
 
 local Notification = loadstring(game:HttpGet("https://raw.githubusercontent.com/FilteringEnabled/FE/main/notificationtest"))();
 local Notify = Notification.Notify;
 
 -- Add a table to keep track of recent notifications
 local recentNotifications = {}
 
 -- Function to check if a notification already exists
 local function notificationExists(text)
	 for _, notification in ipairs(recentNotifications) do
		 if notification == text then
			 return true
		 end
	 end
	 return false
 end
 
 -- Function to add a notification to the recentNotifications table
 local function addNotification(text)
	 table.insert(recentNotifications, text)
	 -- You can limit the size of the recentNotifications table to avoid unlimited growth
	 local maxSize = 10
	 if #recentNotifications > maxSize then
		 table.remove(recentNotifications, 1)
	 end
 end
 
 -- Function to display notifications, with deduplication
 local function onlyoneNotification(text)
	 if not notificationExists(text) then
		 Notify({
			 Description = text,
			 Title = "Cilberion Admin",
			 Duration = 5,
		 })
		 addNotification(text)
	 end
 end

-- [[ for notifications ]] --
local function messageNotification(text)
	Notify({
		Description = text,
		Title = "Cilberion Admin",
		Duration = 5,
	})
end

local function namerequiredNotification()
    local chatMessage = "[+] Name requires at least 2 characters     "
    messageNotification(chatMessage)
end

 -- [[ PREFIX AND OTHER STUFF. ]] -- 
 local opt = {
	prefix = ';', -- If player's executor has the custom file function support it reads the prefix file to get prefix
	tupleSeparator = ',',	-- ;ff me,others,all | ;ff me/others/all
	ui = {					-- never did anything with this
		
	},
	keybinds = {			-- never did anything with this
		
	},
}

 -- [[ Version ]] -- 
 currentversion = "V.1"
 
 -- [[ Specified Commands for localplayer ]] --
 local adminlocal = game.Players.LocalPlayer

 --[[ VARIABLES ]]--
 PlaceId, JobId = game.PlaceId, game.JobId
 local Players = game:GetService("Players")
 local UserInputService = game:GetService("UserInputService")
 local TweenService = game:GetService("TweenService")
 local RunService = game:GetService("RunService")
 local TeleportService = game:GetService("TeleportService")
 local Player = game.Players.LocalPlayer
 local Humanoid = Character and Character:FindFirstChildWhichIsA("Humanoid") or false
 local Character = game.Players.LocalPlayer.Character
 local Clicked = true

SettingsChaos = {
    Killaura = {
        Active = false,
        Distance = 30,
    },
    Givekillaura = {
        Active = false,
        Distance = 30,
    },
    Loopkill = false,
    Autopick = false,
    Loopkillall = false,
}

SettingsUni = {
    Viewing = false,
    Noclip = nil,
    Loopfling = false,
    Loopflingall = false,
}

local loopKillingPlayers = {}

 --[[ Some more variables ]]--
 
 local localPlayer = Players.LocalPlayer
 local LocalPlayer = Players.LocalPlayer
 local character = localPlayer.Character
 local mouse = localPlayer:GetMouse()
 local camera = workspace.CurrentCamera
 local camtype = camera.CameraType
 local Commands, Aliases = {}, {}
 player, plr, lp = localPlayer, localPlayer, localPlayer, localPlayer
 
 localPlayer.CharacterAdded:Connect(function(c)
	 character = c
 end)
 
 local bringc = {}
 local CommandsWHS = {}
local AliasesWHS = {}

 --[[ COMMAND FUNCTIONS ]]--
 commandcount = 0
 cmd = {}

 cmd.add = function(...)
	 local vars = {...}
	 local aliases, info, func = vars[1], vars[2], vars[3]
	 for i, cmdName in pairs(aliases) do
		 if i == 1 then
			 Commands[cmdName:lower()] = {func, info}
		 else
			 Aliases[cmdName:lower()] = {func, info}
		 end
	 end
	 commandcount = commandcount + 1
 end

cmd.addWHS = function(...)
    local varsWHS = {...}
    local aliasesWHS, infoWHS, funcWHS = varsWHS[1], varsWHS[2], varsWHS[3]
    for i, cmdName in pairs(aliasesWHS) do
        if i == 1 then
            CommandsWHS[cmdName:lower()] = {funcWHS, infoWHS}
        else
            AliasesWHS[cmdName:lower()] = {funcWHS, infoWHS}
        end
    end
    commandcount = commandcount + 1
end
 
 cmd.run = function(args)
	 local caller, arguments = args[1], args; table.remove(args, 1);
	 local success, msg = pcall(function()
		 if Commands[caller:lower()] then
			 Commands[caller:lower()][1](unpack(arguments))
		 elseif Aliases[caller:lower()] then
			 Aliases[caller:lower()][1](unpack(arguments))
		 end
	 end)
	 if not success then
	 end
 end
 
cmd.runWHS = function(argsWHS)
    local callerWHS, argumentsWHS = argsWHS[1], argsWHS; table.remove(argsWHS, 1);
    local successWHS, msg = pcall(function()
        if CommandsWHS[callerWHS:lower()] then
            CommandsWHS[callerWHS:lower()][1](unpack(argumentsWHS))
        elseif AliasesWHS[callerWHS:lower()] then
            AliasesWHS[callerWHS:lower()][1](unpack(argumentsWHS))
        end
    end)
    if not successWHS then
    end
end


 --[[ LIBRARY FUNCTIONS ]]--
 lib = {}
 lib.wrap = function(f)
	 return coroutine.wrap(f)()
 end
 
 wrap = lib.wrap
 
 local wait = function(int)
	 if not int then int = 0 end
	 local t = tick()
	 repeat
		 RunService.Heartbeat:Wait(0)
	 until (tick() - t) >= int
	 return (tick() - t), t
 end
 
	 function r15(plr)
		 if game.Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid').RigType == Enum.HumanoidRigType.R15 then
			 return true
		 end
	 end
	 
	 function getRoot(character)
	 local root = game.Players.LocalPlayer.Character:FindFirstChild('HumanoidRootPart') or game.Players.LocalPlayer.Character:FindFirstChild('Torso') or game.Players.LocalPlayer.Character:FindFirstChild('UpperTorso')
	 return root
 end
 
 function getTorso(x)
	x = x or game.Players.LocalPlayer.Character
	return x:FindFirstChild("Torso") or x:FindFirstChild("UpperTorso") or x:FindFirstChild("LowerTorso") or x:FindFirstChild("HumanoidRootPart")
end

 -- [[ FUNCTION TO GET A PLAYER ]] --
 local getPlr = function(Name)
	 if Name:lower() == "random" then
		 return Players:GetPlayers()[math.random(#Players:GetPlayers())]
	 else
		 Name = Name:lower():gsub("%s", "")
		 for _, x in next, Players:GetPlayers() do
			 if x.Name:lower():match(Name) then
				 return x
			 elseif x.DisplayName:lower():match("^" .. Name) then
				 return x
			 end
		 end
	 end
 end
 
 -- [[ MORE VARIABLES ]] --
 plr = game.Players.LocalPlayer
 COREGUI = game:GetService("CoreGui")
 speaker = game.Players.LocalPlayer
 RunService = game:GetService("RunService")


 function getRoot(char)
	 local rootPart = game.Players.LocalPlayer.Character:FindFirstChild('HumanoidRootPart') or game.Players.LocalPlayer.Character:FindFirstChild('Torso') or game.Players.LocalPlayer.Character:FindFirstChild('UpperTorso')
	 return rootPart
 end
 
 local lp = game:GetService("Players").LocalPlayer
 
 
 -- [[ LIB FUNCTIONS ]] --
 lib.lock = function(instance, par)
	 locks[instance] = true
	 instance.Parent = par or instance.Parent
	 instance.Name = "RightGrip"
 end
 lock = lib.lock
 locks = {}
 
 lib.find = function(t, v)	-- mmmmmm
	 for i, e in pairs(t) do
		 if i == v or e == v then
			 return i
		 end
	 end
	 return nil
 end
 
 lib.parseText = function(text, watch)
	 local parsed = {}
	 if not text then return nil end
	 for arg in text:gmatch("[^" .. watch .. "]+") do
		 arg = arg:gsub("-", "%%-")
		 local pos = text:find(arg)
		 arg = arg:gsub("%%", "")
		 if pos then
			 local find = text:sub(pos - opt.prefix:len(), pos - 1)
			 if (find == opt.prefix and watch == opt.prefix) or watch ~= opt.prefix then
				 table.insert(parsed, arg)
			 end
		 else
			 table.insert(parsed, nil)
		 end
	 end
	 return parsed
 end
 
lib.parseCommand = function(text)
	 wrap(function()
		 local commands = lib.parseText(text, opt.prefix)
		 for _, parsed in pairs(commands) do
			 local args = {}
			 for arg in parsed:gmatch("[^ ]+") do
				 table.insert(args, arg)
			 end
			 cmd.run(args)
		 end
	 end)
 end
 
 lib.parseCommandWHS = function(text)
    wrap(function()
        local commands = lib.parseText(text, opt.prefix)
        for _, parsed in pairs(commands) do
            local args = {}
            for arg in parsed:gmatch("[^ ]+") do
                table.insert(args, arg)
            end
            cmd.runWHS(args)
        end
    end)
end
 
 local connections = {}
 
 lib.connect = function(name, connection)	-- no :(
	 connections[name .. tostring(math.random(1000000, 9999999))] = connection
	 return connection
 end
 
 lib.disconnect = function(name)
	 for title, connection in pairs(connections) do
		 if title:find(name) == 1 then
			 connection:Disconnect()
		 end
	 end
 end
 
 m = math			-- prepare for annoying and unnecessary tool grip math
 rad = m.rad
 clamp = m.clamp
 sin = m.sin
 tan = m.tan
 cos = m.cos
 
 --[[ PLAYER FUNCTIONS ]]--
 argument = {}
 argument.getPlayers = function(str)
	 local playerNames, players = lib.parseText(str, opt.tupleSeparator), {}
	 for _, arg in pairs(playerNames or {"me"}) do
		 arg = arg:lower()
		 local playerList = Players:GetPlayers()
		 if arg == "me" or arg == nil then
			 table.insert(players, localPlayer)
			 
		 elseif arg == "all" then
			 for _, plr in pairs(playerList) do
				 table.insert(players, plr)
			 end
			 
		 elseif arg == "others" then
			 for _, plr in pairs(playerList) do
				 if plr ~= localPlayer then
					 table.insert(players, plr)
				 end
			 end
			 
		 elseif arg == "random" then
			 table.insert(players, playerList[math.random(1, #playerList)])
			 
		 elseif arg:find("%%") == 1 then
			 local teamName = arg:sub(2)
			 for _, plr in pairs(playerList) do
				 if tostring(plr.Team):lower():find(teamName) == 1 then
					 table.insert(players, plr)
				 end
			 end
			 
		 else
			 for _, plr in pairs(playerList) do
				 if plr.Name:lower():find(arg) == 1 or (plr.DisplayName and plr.DisplayName:lower():find(arg) == 1) or (tostring(plr.UserId):lower():find(arg) == 1) then
					 table.insert(players, plr)
				 end
			 end
		 end
	 end
	 return players
 end


function equipWeapons(player)
    local character = player.Character
    local backpack = player.Backpack

    if character and backpack then
        for _, tool in pairs(backpack:GetChildren()) do
            local toolName = tool.Name
            if toolName == "Pencil" or toolName == "Chainsaw" or toolName == "Mace" or toolName == "Scythe" or
               toolName == "Pan" or toolName == "Baseball Bat" or toolName == "Blood Dagger" or
               toolName == "Emerald Greatsword" or toolName == "Frost Spear" then
                tool.Parent = character
            end
        end
    end
end

local function getChar()
	return game.Players.LocalPlayer.Character
end

-- [[ Whitelist and Blacklist ]] --

-- Initialize the Admin table
local Admin = {}
Admin[game.Players.LocalPlayer.UserId] = { Player = game.Players.LocalPlayer }

function ChatMessage(Message, Whisper)
    game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(Message, Whisper or "All")
end

local function isAnAdminCommand(Message)
    local adminCommandPrefix = opt.prefix
    return string.sub(Message, 1, #adminCommandPrefix) == adminCommandPrefix
end

 --[[ FUNCTIONALITY ]]--
localPlayer.Chatted:Connect(function(str)
    lib.parseCommand(str)
end)

localPlayer.Chatted:Connect(function(str)
    lib.parseCommandWHS(str)
end)

local function CheckAdminPermissions(Player)
    Player.Chatted:Connect(function(Message)
        if Admin[Player.UserId] then
            if isAnAdminCommand(Message) then
                lib.parseCommand(Message, Player)
            end
        else
            if isAnAdminCommand(Message) then
                local chatMessage = "[+] " .. Player.Name .. " does not have admin privileges"
                messageNotification(chatMessage)
            end
        end
    end)
end

game.Players.PlayerAdded:Connect(function(Player)
    CheckAdminPermissions(Player)
end)

for i, v in pairs(game.Players:GetPlayers()) do
    if v ~= LocalPlayer then
        CheckAdminPermissions(v)
    end
end

local function findPlayer(searchTerm)
    searchTerm = searchTerm:lower() -- Convert the search term to lowercase for a case-insensitive search

    for _, player in pairs(game.Players:GetPlayers()) do
        local playerName = player.Name:lower()
        local displayName = player.DisplayName:lower()

        if playerName:find(searchTerm) or displayName:find(searchTerm) then
            return player
        end
    end

    return nil
end

-- autopick
local weapons = {
    "mace",
    "chainsaw",
    "baseball bat",
    "scythe",
    "pencil",
    "pan",
    "knife",
    "emerald greatsword",
    "blood dagger",
    "frost spear"
}

-- Function to check if a weapon name is valid
local function isValidWeapon(weaponName)
    for _, weapon in pairs(weapons) do
        if weaponName:lower() == weapon then
            return true
        end
    end
    return false
end

-- auto tp pos
local BackupCFrame = nil

local function lol(character)
    local HumanoidRootPart = character:WaitForChild("HumanoidRootPart")
    if BackupCFrame then
        print(BackupCFrame)
        HumanoidRootPart.CFrame = BackupCFrame
    end
    character:WaitForChild("Humanoid").Died:Connect(function()
        BackupCFrame = HumanoidRootPart.CFrame
    end)
end



-- fling function

local Players = game:GetService("Players")
local Player = Players.LocalPlayer
local player = game.Players.LocalPlayer
local mouse = player:GetMouse()
local AllBool = false

local GetPlayer = function(Name)
    Name = Name:lower()
    if Name == "all" or Name == "others" then
        AllBool = true
        return
    elseif Name == "random" then
        local GetPlayers = Players:GetPlayers()
        if table.find(GetPlayers, Player) then table.remove(GetPlayers, table.find(GetPlayers, Player)) end
        return GetPlayers[math.random(#GetPlayers)]
    elseif Name ~= "random" and Name ~= "all" and Name ~= "others" then
        for _,x in next, Players:GetPlayers() do
            if x ~= Player then
                if x.Name:lower():match("^"..Name) then
                    return x;
                elseif x.DisplayName:lower():match("^"..Name) then
                    return x;
                end
            end
        end
    else
        return
    end
end

local SkidFling = function(TargetPlayer)
    local Character = Player.Character
    local Humanoid = Character and Character:FindFirstChildOfClass("Humanoid")
    local RootPart = Humanoid and Humanoid.RootPart
    
    local TCharacter = TargetPlayer.Character
    local THumanoid
    local TRootPart
    local THead
    local Accessory
    local Handle
    
if TCharacter then
    if TCharacter:FindFirstChildOfClass("Humanoid") then
        THumanoid = TCharacter:FindFirstChildOfClass("Humanoid")
    end
    if THumanoid and THumanoid.RootPart then
        TRootPart = THumanoid.RootPart
    end
    if TCharacter:FindFirstChild("Head") then
        THead = TCharacter.Head
    end
    if TCharacter:FindFirstChildOfClass("Accessory") then
        Accessory = TCharacter:FindFirstChildOfClass("Accessory")
    end
    if Accessoy and Accessory:FindFirstChild("Handle") then
        Handle = Accessory.Handle
    end
end
    
    if Character and Humanoid and RootPart and TCharacter then
        if RootPart.Velocity.Magnitude < 50 then
            getgenv().OldPos = RootPart.CFrame
        end
        if THumanoid and THumanoid.Sit and not AllBool then
                local chatMessage = "[+] Target is currently sitting"
                messageNotification(chatMessage)
        end
        if THead then
            workspace.CurrentCamera.CameraSubject = THead
        elseif not THead and Handle then
            workspace.CurrentCamera.CameraSubject = Handle
        elseif THumanoid and TRootPart then
            workspace.CurrentCamera.CameraSubject = THumanoid
        end
        if not TCharacter:FindFirstChildWhichIsA("BasePart") then
            return
        end
        
        local FPos = function(BasePart, Pos, Ang)
            RootPart.CFrame = CFrame.new(BasePart.Position) * Pos * Ang
            Character:SetPrimaryPartCFrame(CFrame.new(BasePart.Position) * Pos * Ang)
            RootPart.Velocity = Vector3.new(9e7, 9e7 * 10, 9e7)
            RootPart.RotVelocity = Vector3.new(9e8, 9e8, 9e8)
        end
        
        local SFBasePart = function(BasePart)
            local TimeToWait = 2
            local Time = tick()
            local Angle = 0
    
            repeat
                if RootPart and THumanoid and TCharacter then
                    if BasePart.Velocity.Magnitude < 50 then
                        Angle = Angle + 100
    
                        FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle),0 ,0))
                        task.wait()
    
                        FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()
    
                        FPos(BasePart, CFrame.new(2.25, 1.5, -2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()
    
                        FPos(BasePart, CFrame.new(-2.25, -1.5, 2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()
    
                        FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection,CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()
    
                        FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection,CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()
                    else
                        FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()
    
                        FPos(BasePart, CFrame.new(0, -1.5, -THumanoid.WalkSpeed), CFrame.Angles(0, 0, 0))
                        task.wait()
    
                        FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()
                        
                        FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()
    
                        FPos(BasePart, CFrame.new(0, -1.5, -TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(0, 0, 0))
                        task.wait()
    
                        FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()
    
                        FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()
    
                        FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
                        task.wait()
    
                        FPos(BasePart, CFrame.new(0, -1.5 ,0), CFrame.Angles(math.rad(-90), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
                        task.wait()
                    end
                else
                    break
                end
            until BasePart.Velocity.Magnitude > 500 or BasePart.Parent ~= TargetPlayer.Character or TargetPlayer.Parent ~= Players or not TargetPlayer.Character == TCharacter or THumanoid.Sit or Humanoid.Health <= 0 or tick() > Time + TimeToWait
        end
        
        workspace.FallenPartsDestroyHeight = 0/0
        
        local BV = Instance.new("BodyVelocity")
        BV.Name = "Cilberion On Top"
        BV.Parent = RootPart
        BV.Velocity = Vector3.new(9e8, 9e8, 9e8)
        BV.MaxForce = Vector3.new(1/0, 1/0, 1/0)
        
        Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
        
        if TRootPart and THead then
            if (TRootPart.CFrame.p - THead.CFrame.p).Magnitude > 5 then
                SFBasePart(THead)
            else
                SFBasePart(TRootPart)
            end
        elseif TRootPart and not THead then
            SFBasePart(TRootPart)
        elseif not TRootPart and THead then
            SFBasePart(THead)
        elseif not TRootPart and not THead and Accessory and Handle then
            SFBasePart(Handle)
            else
                return
        end
        
        BV:Destroy()
        Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
        workspace.CurrentCamera.CameraSubject = Humanoid
        
            repeat
                RootPart.CFrame = getgenv().OldPos * CFrame.new(0, .5, 0)
                Character:SetPrimaryPartCFrame(getgenv().OldPos * CFrame.new(0, .5, 0))
                Humanoid:ChangeState("GettingUp")
                table.foreach(Character:GetChildren(), function(_, x)
                    if x:IsA("BasePart") then
                        x.Velocity, x.RotVelocity = Vector3.new(), Vector3.new()
                    end
                end)
                task.wait()
            until (RootPart.Position - getgenv().OldPos.p).Magnitude < 25
            workspace.FallenPartsDestroyHeight = getgenv().FPDH
        else
    end
end
   


local ShiftLockScreenGui = Instance.new("ScreenGui")
local ShiftlockCursor = Instance.new("ImageLabel")
local CoreGui = game:GetService("CoreGui")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ContextActionService = game:GetService("ContextActionService")
local Player = Players.LocalPlayer
local UserInputService = game:GetService("UserInputService")

local States = {
    Lock = "http://www.roblox.com/asset/?id=182223762",
}

local MaxLength = 900000
local EnabledOffset = CFrame.new(1.7, 0, 0)
local DisabledOffset = CFrame.new(-1.7, 0, 0)
local Active
local LeftCtrlPressed = false
local ShiftLockEnabled = true -- Variable to track if custom Shift Lock is enabled

ShiftLockScreenGui.Name = "Shiftlock (CoreGui)"
ShiftLockScreenGui.Parent = CoreGui
ShiftLockScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
ShiftLockScreenGui.ResetOnSpawn = false

ShiftlockCursor.Name = "Shiftlock Cursor"
ShiftlockCursor.Parent = ShiftLockScreenGui
ShiftlockCursor.Image = States.Lock
ShiftlockCursor.Size = UDim2.new(0, 32, 0, 32)
ShiftlockCursor.Position = UDim2.new(0.5, -16, 0.5, -16)
ShiftlockCursor.AnchorPoint = Vector2.new(0.5, 0.5)
ShiftlockCursor.SizeConstraint = Enum.SizeConstraint.RelativeXX
ShiftlockCursor.BackgroundTransparency = 1
ShiftlockCursor.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
ShiftlockCursor.Visible = false

local function ToggleShiftLock()
    if not Active then
        Active = RunService.RenderStepped:Connect(function()
            Player.Character.Humanoid.AutoRotate = false
            ShiftlockCursor.Visible = true
            Player.Character.HumanoidRootPart.CFrame = CFrame.new(
                Player.Character.HumanoidRootPart.Position,
                Vector3.new(workspace.CurrentCamera.CFrame.LookVector.X * MaxLength, Player.Character.HumanoidRootPart.Position.Y, workspace.CurrentCamera.CFrame.LookVector.Z * MaxLength))
            workspace.CurrentCamera.CFrame = workspace.CurrentCamera.CFrame * EnabledOffset
            workspace.CurrentCamera.Focus = CFrame.fromMatrix( workspace.CurrentCamera.Focus.Position, workspace.CurrentCamera.CFrame.RightVector, workspace.CurrentCamera.CFrame.UpVector) * EnabledOffset
            UserInputService.MouseIconEnabled = false
            UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
        end)
    else
        Player.Character.Humanoid.AutoRotate = true
        workspace.CurrentCamera.CFrame = workspace.CurrentCamera.CFrame * DisabledOffset
        ShiftlockCursor.Visible = false

        pcall(function()
            Active:Disconnect()
            Active = nil
        end)

        UserInputService.MouseIconEnabled = true
        UserInputService.MouseBehavior = Enum.MouseBehavior.Default
    end
end

local function ToggleCustomShiftLock()
    if not Active then
        ToggleShiftLock() -- Activate custom Shift Lock
    else
        if Active then
            ToggleShiftLock() -- Deactivate custom Shift Lock
        end
    end
end

local function UncustomShiftLock()
    ShiftLockEnabled = false -- Completely disable custom Shift Lock
    if Active then
        ToggleShiftLock() -- Turn off custom Shift Lock
    end
end

local chshtog = false

local function OnLeftCtrlPress()
    LeftCtrlPressed = not LeftCtrlPressed
    if LeftCtrlPressed then
		chshtog = false
        UncustomShiftLock() -- Turn off custom Shift Lock when Left Ctrl is pressed
    else
		chshtog = true
        ToggleCustomShiftLock() -- Toggle custom Shift Lock when Left Ctrl is released
    end
end


-- Define a variable to track the custom shift lock state
local isCustomShiftLockEnabled = false

-- Function to enable custom shift lock
local function EnableCustomShiftLock()
    if not isCustomShiftLockEnabled then
        isCustomShiftLockEnabled = true
        local ShiftLockAction = ContextActionService:BindAction("Shift Lock", ToggleShiftLock, false, "On")
		ContextActionService:SetPosition("Shift Lock", UDim2.new(0.8, 0, 0.8, 0))

		UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
			if not gameProcessedEvent and input.KeyCode == Enum.KeyCode.LeftControl then
				OnLeftCtrlPress()
			end
		end)
		local chatMessage = "[+] Custom Shiftlock is enabled"
		messageNotification(chatMessage)
		return {} and ShiftLockAction
    else
		local chatMessage = "[+] Custom Shiftlock has already been enabled"
		messageNotification(chatMessage)
    end
end

-- Function to disable custom shift lock
local function DisableCustomShiftLock()
    if isCustomShiftLockEnabled then
		if chshtog == true then
			OnLeftCtrlPress()
			task.wait(0.2)
			isCustomShiftLockEnabled = false
			local ShiftLockAction = ContextActionService:BindAction("Shift Lock", ToggleShiftLock, false, "On")
			ContextActionService:SetPosition("Shift Lock", UDim2.new(0.8, 0, 0.8, 0))

			UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
				if not gameProcessedEvent and input.KeyCode == Enum.KeyCode.LeftControl then
					OnLeftCtrlPress()
				end
			end)
			local chatMessage = "[+] Custom Shiftlock has been disabled"
			messageNotification(chatMessage)
			return {} and ShiftLockAction
    	else
			isCustomShiftLockEnabled = false
			local ShiftLockAction = ContextActionService:BindAction("Shift Lock", ToggleShiftLock, false, "On")
			ContextActionService:SetPosition("Shift Lock", UDim2.new(0.8, 0, 0.8, 0))
	
			UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
				if not gameProcessedEvent and input.KeyCode == Enum.KeyCode.LeftControl then
					OnLeftCtrlPress()
				end
			end)
			local chatMessage = "[+] Custom Shiftlock has been disabled"
			messageNotification(chatMessage)
			return {} and ShiftLockAction
		end
	else
        local chatMessage = "[+] Custom Shiftlock isn't on yet. Use customshiftlock/customsh to enable custom shiftlock"
        messageNotification(chatMessage)
	end
end




 --[[ COMMANDS CHAOS ]]--

cmd.add({"exit", "ex"}, {"exit (ex)", "Closes Roblox"}, function()
    local chatMessage = "[+] Closing"
    messageNotification(chatMessage)
    game:Shutdown()
end)

cmd.add({"rejoin", "rj"}, {"rejoin (rj)", "Rejoins the game"}, function()
    local chatMessage = "[+] Rejoining"
    messageNotification(chatMessage)
    game:GetService("TeleportService"):Teleport(game.PlaceId)
    wait()
end)


cmd.add({"serverhop", "shop"}, {"serverhop (shop)", "Serverhop"}, function()
    local chatMessage = "[+] Finding a new server"
    messageNotification(chatMessage)
    local Number = 0
    local SomeSRVS = {}
    for _, v in ipairs(game:GetService("HttpService"):JSONDecode(game:HttpGetAsync("https://games.roblox.com/v1/games/" .. game.PlaceId .. "/servers/Public?sortOrder=Asc&limit=100")).data) do
        if type(v) == "table" and v.maxPlayers > v.playing and v.id ~= game.JobId then
            if v.playing > Number then
                Number = v.playing
                SomeSRVS[1] = v.id
            end
        end
    end
    if #SomeSRVS > 0 then
        local chatMessage = "[+] Successfully found a server"
        messageNotification(chatMessage)
		game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, SomeSRVS[1])
    else
        local chatMessage = "[+] Couldn't find a server"
        messageNotification(chatMessage)
	end
 end)

 cmd.add({"rjre", "rejoinrefresh"}, {"rjre (rejoinrefresh)", "Rejoins and teleports you to the position where you were before"}, function()
	queueteleport = (syn and syn.queue_on_teleport) or queue_on_teleport or (fluxus and fluxus.queue_on_teleport)
	
	if not DONE then
	  DONE = true
	  local chatMessage = "[+] Rejoining and teleporting you to your previous position"
	  messageNotification(chatMessage)
	  local qot = print("a")
	  local hrp = game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
	  if hrp then
		qot = "task.spawn(function() end) repeat wait() until game and game:IsLoaded() local lp = game:GetService('Players').LocalPlayer local char = lp.Character or lp.CharacterAdded:Wait() repeat char:WaitForChild('HumanoidRootPart').CFrame = CFrame.new("..tostring(hrp.CFrame)..") wait() until (Vector3.new("..tostring(hrp.Position)..") - char:WaitForChild('HumanoidRootPart').Position).Magnitude < 10"
	  end
	  queueteleport(qot)
	  game:GetService("TeleportService"):TeleportCancel()
		game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, game.JobId, game.Players.LocalPlayer)
	end
end)

cmd.add({"view", "vw"}, {"view <username>", "Views the given player"}, function(player)
    local args = {player}

    if #args == 0 then
        local chatMessage = "[+] Invalid command format. Use view/vw (username)"
        messageNotification(chatMessage)
        return
    end

    -- Check if the username is less than 2 characters
    if #args[1] < 2 then
        namerequiredNotification()
        return
    end

    local Target = findPlayer(player)

    if not Target then
        local chatMessage = "[+] No matching username or display name found"
        messageNotification(chatMessage)
        return
    end

    game.Workspace.CurrentCamera.CameraSubject = character:FindFirstChildWhichIsA("Humanoid")
    SettingsUni.Viewing = false

    -- Reduced wait time for faster camera switching
    task.wait()

    SettingsUni.Viewing = true

    repeat
        task.wait()
        workspace.CurrentCamera.CameraSubject = Target.Character.Humanoid
    until not SettingsUni.Viewing
end)

-- Command to enable position tracking
cmd.add({"autooldpos", "autogoback", "aop"}, {"autooldpos (aop)", "Teleports you where you last died"}, function()
    SettingsUni.Autoposition = true
    player = game:GetService("Players").LocalPlayer

    -- Initial setup
    if player.Character and SettingsUni.Autoposition then
        lol(player.Character)
    end

    local chatMessage = "[+] Auto-TP Position has been enabled"
    messageNotification(chatMessage)
    
        -- Connect the CharacterAdded event
    player.CharacterAdded:Connect(function(character)
        if SettingsUni.Autoposition then
            lol(character)
        end
    end)

end)

-- Command to disable position tracking
cmd.add({"unautooldpos", "unautogoback", "unaop"}, {"unautooldpos (unaop)", "Stops teleporting you back where you last died"}, function()
    SettingsUni.Autoposition = false
    local chatMessage = "[+] Auto-TP Position has been disabled"
    messageNotification(chatMessage)
end)

cmd.add({"unview", "unvw"}, {"unview", "Unview the currently viewed player"}, function()
    local character = game.Players.LocalPlayer.Character
    SettingsUni.Viewing = false
    task.wait()
    game.Workspace.CurrentCamera.CameraSubject = character:FindFirstChildWhichIsA("Humanoid")
    local chatMessage = "[+] Viewing has been disabled"
    messageNotification(chatMessage)
end)

cmd.add({"spook", "spk"}, {"spook <player>", "Teleports next to a player for a few seconds"}, function(...)
	local args = {...}
    local searchLetters = table.concat(args, " ")

    if #args == 0 then
        local chatMessage = "[+] Invalid command format. Use spook/spk (username)"
        messageNotification(chatMessage)
        return
    end

    -- Check if the username is less than 2 characters
    if #args[1] < 2 then
        namerequiredNotification()
        return
    end

	Username = (...)
	Target = getPlr(Username)
	
	
	local oldCF = LocalPlayer.Character.HumanoidRootPart.CFrame
	Target = getPlr(Username)    
	distancepl = 2
		if Target.Character and Target.Character:FindFirstChild('Humanoid') then
		LocalPlayer.Character.HumanoidRootPart.CFrame = Target.Character.HumanoidRootPart.CFrame +  Target.Character.HumanoidRootPart.CFrame.lookVector * distancepl
		LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(LocalPlayer.Character.HumanoidRootPart.Position, Target.Character.HumanoidRootPart.Position)
		wait(.5)
		LocalPlayer.Character.HumanoidRootPart.CFrame = oldCF
	end
end)

local isBangEnabled = false  -- Initialize the flag to false
local bangLoop = nil
local bang = nil
local bangAnim = nil
local bangDied = nil

local player = game.Players.LocalPlayer

local function disableBang()
    if isBangEnabled then
        if bangLoop then
            bangLoop:Disconnect()
        end
        if bang then
            bang:Stop()
        end
        if bangAnim then
            bangAnim:Destroy()
        end
        if bangDied then
            bangDied:Disconnect()
        end

        isBangEnabled = false
    end
end

player.CharacterRemoving:Connect(function()
	if isBangEnabled then
		disableBang()  -- Automatically disable banging when the character is removed (reset)
		local chatMessage = "[+] ".. game.Players.LocalPlayer.DisplayName  .." died, banging has been disabled       "
		messageNotification(chatMessage)
	end
end)

cmd.add({"chatlogs", "clogs"}, {"chatlogs (clogs)", "Open the chat logs"}, function()
	gui.chatlogs()
end)

cmd.add({"goto", "to", "tp", "teleport"}, {"goto <player/X,Y,Z>", "Teleport to the given player or X,Y,Z coordinates"}, function(...)
	Username = (...)

	local target = getPlr(Username)
	getChar().HumanoidRootPart.CFrame = target.Character.Humanoid.RootPart.CFrame
end)

cmd.add({"follow", "stalk", "walk"}, {"follow <player>", "Follow a player wherever they go"}, function(p)
	lib.disconnect("follow")
	local players = argument.getPlayers(p)
	local targetPlayer = players[1]
	lib.connect("follow", RunService.Stepped:Connect(function()
		local target = targetPlayer.Character
		if target and character then
			local hum = character:FindFirstChildWhichIsA("Humanoid")
			if hum then
				local targetPart = target:FindFirstChild("Head")
				local targetPos = targetPart.Position
				hum:MoveTo(targetPos)
			end
		end
	end))
end)

cmd.add({"unfollow", "unstalk", "unwalk", "unpathfind"}, {"unfollow", "Stop all attempts to follow a player"}, function()
    lib.disconnect("follow")
end)

cmd.add({"hitboxes"}, {"hitboxes", "shows all the hitboxes"}, function()
 settings():GetService("RenderSettings").ShowBoundingBoxes = true
 local chatMessage = "[+] Showing hitboxes"
 messageNotification(chatMessage)
end)
 
cmd.add({"unhitboxes"}, {"unhitboxes", "removes the hitboxes outline"}, function()
 settings():GetService("RenderSettings").ShowBoundingBoxes = false
 local chatMessage = "[+] Show hitboxes off"
 messageNotification(chatMessage)
end)
 

AntiFling = false

cmd.add({"antifling", "antfl"}, {"antifling (antfl)", "Makes it so you can't collide with others"}, function()
    AntiFling = true

    local function NoCollision(PLR)
        if AntiFling and PLR.Character then
            for _, x in pairs(PLR.Character:GetDescendants()) do
                if x:IsA("BasePart") and x.CanCollide then
                    x.CanCollide = false
                end
            end
        end
    end

    local antifling = {}
    for _, v in pairs(game.Players:GetPlayers()) do
        if v ~= game.Players.LocalPlayer then
            antifling[v] = game:GetService('RunService').Stepped:Connect(function()
                NoCollision(v)
            end)
        end
    end

    game.Players.PlayerAdded:Connect(function(player)
        if player ~= game.Players.LocalPlayer and antifling[player] then
            antifling[player] = game:GetService('RunService').Stepped:Connect(function()
                NoCollision(player)
            end)
        end
    end)

    wait()
    local chatMessage = "[+] Anti fling enabled"
	messageNotification(chatMessage)

end)

cmd.add({"unantifling", "unantfl"}, {"unantifling (unantfl)", "Disables antifling"}, function()
    AntiFling = false

    wait()

    local chatMessage = "[+] Anti fling has been disabled"
	messageNotification(chatMessage)

    for _, v in pairs(game.Players:GetPlayers()) do
        if v ~= game.Players.LocalPlayer then
            local char = v.Character
            for _, x in pairs(char:GetDescendants()) do
                if x:IsA("BasePart") then
                    x.CanCollide = true
                end
            end
        end
    end
end)

cmd.add({"uwpfpsboost", "uwpfb"}, {"uwpfpsboost (uwpfb)", "Boosts FPS for UWP"}, function()
	local chatMessage = "[+] Boosting FPS for UWP"
	messageNotification(chatMessage)
	repeat task.wait() until game:IsLoaded();

	getgenv().boostFPS = true

	local vim = game:GetService("VirtualInputManager")
	setfpscap(5000)

	game.DescendantAdded:Connect(function(d)
		if d.Name == "MainView" and d.Parent.Name == "DevConsoleUI" and boostFPS then
			task.wait()
			local screen = d.Parent.Parent.Parent
			screen.Enabled = false;
		end
	end)

	vim:SendKeyEvent(true, "F9", 0, game)    
	wait()
	vim:SendKeyEvent(false, "F9", 0, game)  

	while true do
	task.wait()
	if not boostFPS then
		continue;
	end
	

	warn("")
	
	if not game:GetService("CoreGui"):FindFirstChild("DevConsoleUI", true):FindFirstChild("MainView") then
		vim:SendKeyEvent(true, "F9", 0, game)    
			wait()
			vim:SendKeyEvent(false, "F9", 0, game)  
			continue
		end
	end
end)



local cmdlp = game.Players.LocalPlayer
 
plr = cmdlp

workspace = game.workspace

cmdm = plr:GetMouse()

function sFLY(vfly)
    FLYING = false
    speedofthefly = 10
    speedofthevfly = 10
    while not cmdlp or not cmdlp.Character or not cmdlp.Character:FindFirstChild('HumanoidRootPart') or not cmdlp.Character:FindFirstChild('Humanoid') or not cmdm do
         wait()
    end 
    local T = cmdlp.Character.HumanoidRootPart
    local CONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
    local lCONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
    local SPEED = 0
    local function FLY()
        FLYING = true
        local BG = Instance.new('BodyGyro', T)
        local BV = Instance.new('BodyVelocity', T)
        BG.P = 9e4
        BG.maxTorque = Vector3.new(9e9, 9e9, 9e9)
        BG.cframe = T.CFrame
        BV.velocity = Vector3.new(0, 0, 0)
        BV.maxForce = Vector3.new(9e9, 9e9, 9e9)
        spawn(function()
            while FLYING do
                if not vfly then
                    cmdlp.Character:FindFirstChild("Humanoid").PlatformStand = true
                end
                if CONTROL.L + CONTROL.R ~= 0 or CONTROL.F + CONTROL.B ~= 0 or CONTROL.Q + CONTROL.E ~= 0 then
                    SPEED = 50
                elseif not (CONTROL.L + CONTROL.R ~= 0 or CONTROL.F + CONTROL.B ~= 0 or CONTROL.Q + CONTROL.E ~= 0) and SPEED ~= 0 then
                    SPEED = 0
                end
                if (CONTROL.L + CONTROL.R) ~= 0 or (CONTROL.F + CONTROL.B) ~= 0 or (CONTROL.Q + CONTROL.E) ~= 0 then
                    BV.velocity = ((workspace.CurrentCamera.CoordinateFrame.lookVector * (CONTROL.F + CONTROL.B)) + ((workspace.CurrentCamera.CoordinateFrame * CFrame.new(CONTROL.L + CONTROL.R, (CONTROL.F + CONTROL.B + CONTROL.Q + CONTROL.E) * 0.2, 0).p) - workspace.CurrentCamera.CoordinateFrame.p)) * SPEED
                    lCONTROL = {F = CONTROL.F, B = CONTROL.B, L = CONTROL.L, R = CONTROL.R}
                elseif (CONTROL.L + CONTROL.R) == 0 and (CONTROL.F + CONTROL.B) == 0 and (CONTROL.Q + CONTROL.E) == 0 and SPEED ~= 0 then
                    BV.velocity = ((workspace.CurrentCamera.CoordinateFrame.lookVector * (lCONTROL.F + lCONTROL.B)) + ((workspace.CurrentCamera.CoordinateFrame * CFrame.new(lCONTROL.L + lCONTROL.R, (lCONTROL.F + lCONTROL.B + CONTROL.Q + CONTROL.E) * 0.2, 0).p) - workspace.CurrentCamera.CoordinateFrame.p)) * SPEED
                else
                    BV.velocity = Vector3.new(0, 0, 0)
                end
                BG.cframe = workspace.CurrentCamera.CoordinateFrame
                wait()
            end
            CONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
            lCONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
            SPEED = 0
            BG:destroy()
            BV:destroy()
            cmdlp.Character.Humanoid.PlatformStand = false
        end)
    end
    cmdm.KeyDown:connect(function(KEY)
        if KEY:lower() == 'w' then
            if vfly then
                CONTROL.F = speedofthevfly
            else
                CONTROL.F = speedofthefly
            end
        elseif KEY:lower() == 's' then
            if vfly then
                CONTROL.B = - speedofthevfly
            else
                CONTROL.B = - speedofthefly
            end
        elseif KEY:lower() == 'a' then
            if vfly then
                CONTROL.L = - speedofthevfly
            else
                CONTROL.L = - speedofthefly
            end
        elseif KEY:lower() == 'd' then
            if vfly then
                CONTROL.R = speedofthevfly
            else
                CONTROL.R = speedofthefly
            end
        elseif KEY:lower() == 'y' then
            if vfly then
                CONTROL.Q = speedofthevfly*2
            else
                CONTROL.Q = speedofthefly*2
            end
        elseif KEY:lower() == 't' then
            if vfly then
                CONTROL.E = -speedofthevfly*2
            else
                CONTROL.E = -speedofthefly*2
            end
        end
    end)
    cmdm.KeyUp:connect(function(KEY)
        if KEY:lower() == 'w' then
            CONTROL.F = 0
        elseif KEY:lower() == 's' then
            CONTROL.B = 0
        elseif KEY:lower() == 'a' then
            CONTROL.L = 0
        elseif KEY:lower() == 'd' then
            CONTROL.R = 0
        elseif KEY:lower() == 'y' then
            CONTROL.Q = 0
        elseif KEY:lower() == 't' then
            CONTROL.E = 0
        end
    end)
    FLY()
end

local flyPart
 cmd.add({"fly", "bird", "mosquito"}, {"fly <speed>", "Fly freely like a mosquito"}, function(...)
 FLYING = false
	 cmdlp.Character.Humanoid.PlatformStand = false
	 wait()
		local chatMessage = "[+] Flying"
        messageNotification(chatMessage)
	 sFLY(true)
	 speedofthevfly = (...)
	 if (...) == nil then
		local chatMessage = "[+] No flying speed set, defaults to 2"
		messageNotification(chatMessage)
		speedofthevfly = 2
	else
		local chatMessage = "[+] Flying speed set to " .. speedofthevfly .. ""
		messageNotification(chatMessage)
	end
 end)
 
cmd.add({"unfly", "unbird", "unmosquito"}, {"unfly", "Disable flight"}, function()
	if not FLYING then
		local chatMessage = "[+] Flying isn't on yet. Use fly/bird/mosquito to enable flying"
		messageNotification(chatMessage)
	else
		local chatMessage = "[+] Flying has been disabled"
		messageNotification(chatMessage)
		FLYING = false
		cmdlp.Character.Humanoid.PlatformStand = false
	end
 end)

 cmd.add({"noclip", "ncp"}, {"noclip (ncp)", "No-clips through objects"}, function()
    local chatMessage = "[+] No-clip is enabled"
    messageNotification(chatMessage)
    Clip = false
	wait(0.1)
	local function NoclipLoop()
		if Clip == false and lp.Character ~= nil then
			for _, child in pairs(lp.Character:GetDescendants()) do
				if child:IsA("BasePart") and child.CanCollide == true and child.Name ~= floatName then
					child.CanCollide = false
				end
			end
		end
	end
	SettingsUni.Noclip = RunService.Stepped:Connect(NoclipLoop)
end)

cmd.add({"clip", "unnoclip", "unncp"}, {"clip (unncp)", "Stops No-clip"}, function()
    if SettingsUni.Noclip then
		SettingsUni.Noclip:Disconnect()
        local chatMessage = "[+] No-clip has been disabled"
        messageNotification(chatMessage)
	end
	Clip = true
end)

cmd.add({"volume", "vol"}, {"volume <1-10> (vol)", "Changes your volume"}, function(vol)
	amount = vol/10
	UserSettings():GetService("UserGameSettings").MasterVolume = amount
end)

cmd.add({"sensitivity", "sens"}, {"sensitivity <1-10> (tr)", "Changes your sensitivity"}, function(ss)
	game:GetService("UserInputService").MouseDeltaSensitivity = ss
end)

-- Variable to track if the antivoid feature is active
local antivoidEnabled = false

-- Variable to track if the notification has been shown
local notificationShown = false

-- Function to check and reset the player's position
local function checkAndResetPlayerPosition()
    local player = game.Players.LocalPlayer
    if player and player.Character then
        local humanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
        if humanoidRootPart then
            local yPosition = humanoidRootPart.Position.Y
            if yPosition <= -250 and not notificationShown then
                if antivoidEnabled then
                    -- Reset the player's position only if antivoid is enabled
                    player.Character.Humanoid.Health = 0
					local chatMessage = "[+] You have been resetted because his/her Y-position was below -250 Y-axis"
					messageNotification(chatMessage)
                    notificationShown = true
                end
            elseif yPosition > -250 and notificationShown then
                -- Reset the notification flag when the Y position is no longer below -250
                notificationShown = false
            end
        end
    end
end

-- Connect the checkAndResetPlayerPosition function to the Heartbeat event
local runService = game:GetService("RunService")

-- Command to enable the antivoid feature
cmd.add({"antivoid", "av"}, {"antivoid (av)", "Automatically resets when you are about to fall in the void"}, function()
    if not antivoidEnabled then
        -- Enable the antivoid feature
        antivoidEnabled = true
        runService.Heartbeat:Connect(checkAndResetPlayerPosition)
		local chatMessage = "[+] Antivoid has been enabled"
		messageNotification(chatMessage)
    else
		local chatMessage = "[+] Antivoid feature is already running. Use 'unantivoid/unav' to disable it"
		messageNotification(chatMessage)
    end
end)

-- Command to turn off the antivoid feature
cmd.add({"unantivoid", "unav"}, {"unantivoid (unav)", "Disable the antivoid feature"}, function()
    if antivoidEnabled then
        antivoidEnabled = false
		local chatMessage = "[+] Antivoid has been disabled"
		messageNotification(chatMessage)
        runService.Heartbeat:Disconnect(checkAndResetPlayerPosition)
        notificationShown = false -- Reset the notification flag
    else
		local chatMessage = "[+] Antivoid isn't on yet. Use antivoid/av to enable antivoid"
		messageNotification(chatMessage)
    end
end)



cmd.add({""}, {"customshiftlock (customsh)", "Custom shiftlock if your UWP doesn't have one"}, function()
	print(chshtog)
end)


-- Add commands to enable and disable custom shift lock
cmd.add({"customshiftlock", "cshfl", "customsh"}, {"customshiftlock (customsh)", "Custom shiftlock if your UWP doesn't have one"}, EnableCustomShiftLock)

cmd.add({"uncustomshiftlock", "uncshfl", "uncustomsh"}, {"uncustomshiftlock (uncustomsh)", "Turn off custom Shift Lock"}, DisableCustomShiftLock)
	

cmd.add({"bang", "fuck"}, {"bang <player> <speed>", "Bangs the player by attaching to them"}, function(h, d)
    if isBangEnabled then
        local chatMessage = "[+] Banging is already running. Use 'unbang' to disable it."
        messageNotification(chatMessage)
        return
    end

    local speed = d
    if speed == nil then
        speed = 10
    end

    Username = h
    local Target = getPlr(Username)
		bangAnim = Instance.new("Animation")
		if not r15(game.Players.LocalPlayer) then
			bangAnim.AnimationId = "rbxassetid://148840371"
		else
			bangAnim.AnimationId = "rbxassetid://5918726674"
		end
		bang = game.Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid'):LoadAnimation(bangAnim)
		bang:Play(.1, 1, 1)
		if speed then
			bang:AdjustSpeed(speed)
		else
			bang:AdjustSpeed(3)
		end
		local bangplr = Target.Name
		bangDied = game.Players.LocalPlayer.Character:FindFirstChildOfClass'Humanoid'.Died:Connect(function()
			bangLoop = bangLoop:Disconnect()
			bang:Stop()
			bangAnim:Destroy()
			bangDied:Disconnect()
		end)
		local bangOffet = CFrame.new(0, 0, 1.1)
		bangLoop = RunService.Stepped:Connect(function()
			pcall(function()
				local otherRoot = getTorso(game.Players[bangplr].Character)
				getRoot(game.Players.LocalPlayer.Character).CFrame = otherRoot.CFrame * bangOffet
			end)
		end)
	task.wait()
	local chatMessage = "[+] Banging: " .. Target.Name .. " with speed " .. speed .. ""
	messageNotification(chatMessage)
	isBangEnabled = true  -- Set the flag to true to indicate that "bang" is active
end)

cmd.add({"unbang", "unfuck"}, {"unbang", "Unbangs the player"}, function()
    if isBangEnabled then
        local chatMessage = "[+] Banging has been disabled"
        messageNotification(chatMessage)
        bangLoop = bangLoop:Disconnect()
		disableBang()

        isBangEnabled = false  -- Set the flag to false to indicate that "bang" is disabled
    else
        local chatMessage = "[+] Banging is not active. Use 'bang (player) (speed)' to enable it."
        messageNotification(chatMessage)
    end
end)


cmd.add({"headbang", "mouthbang", "hb", "mb"}, {"headbang <player> (mouthbang, hb, mb)", "Bang them in the mouth because you are gay"}, function(h,d)
    RunService = game:GetService("RunService")
    
        speed = d
    
        if speed == nil then
    speed = 10
        end
        
        Username = h
        
        local players = getPlr(Username)
        bangAnim = Instance.new("Animation")
        if not r15(game.Players.LocalPlayer) then
            bangAnim.AnimationId = "rbxassetid://148840371"
        else
            bangAnim.AnimationId = "rbxassetid://5918726674"
        end
        bang = game.Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid'):LoadAnimation(bangAnim)
        bang:Play(.1, 1, 1)
        if speed then
            bang:AdjustSpeed(speed)
        else
            bang:AdjustSpeed(3)
        end
        local bangplr = players.Name
        bangDied = game.Players.LocalPlayer.Character:FindFirstChildOfClass'Humanoid'.Died:Connect(function()
            bangLoop = bangLoop:Disconnect()
            bang:Stop()
            bangAnim:Destroy()
            bangDied:Disconnect()
        end)
        local bangOffet = CFrame.new(0, 1, -1.1)
        bangLoop = RunService.Stepped:Connect(function()
        pcall(function()
            local otherRoot = game.Players[bangplr].Character.Head
            game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = otherRoot.CFrame * bangOffet
            local CharPos = game.Players.LocalPlayer.Character.PrimaryPart.Position
            local tpos = players.Character:FindFirstChild("HumanoidRootPart").Position
            local TPos = Vector3.new(tpos.X,CharPos.Y,tpos.Z)
            local NewCFrame = CFrame.new(CharPos,TPos)
            Players.LocalPlayer.Character:SetPrimaryPartCFrame(NewCFrame)
        end)
    end)
end)
    
cmd.add({"unheadbang", "unmouthbang", "unhb", "unmb"}, {"unheadbang (unmouthbang, unhb, unmb)", "Bang them in the mouth because you are gay"}, function(h,d)
    if bangLoop then
        bangLoop = bangLoop:Disconnect()
        bang:Stop()
        bangAnim:Destroy()
        bangDied:Disconnect()
    end
end)


cmd.add({"commands", "cmds", "help"}, {"commands (cmds)", "Open the command list"}, function()
    gui.commands()
end)

cmd.add({"weaponavail", "wpav"}, {"weaponavail (wpav)", "Lists of available weapons to autopick"}, function()
    local chatMessage = "[+] The weapons can be shortened so you don't have to type the full weapon name\n\n[+] Available weapons: You can use every weapons (paid ones too)"
    messageNotification(chatMessage)
end)

cmd.add({"autopick", "ap"}, {"autopick <weaponname>", "Autopicks the weapon name (including paid), can be shortened"}, function(...)
    local args = {...}
    local searchLetters = table.concat(args, " ")

    if #args == 0 then
        local chatMessage = "[+] Invalid command format. Use autopick/ap (weaponname)\n\n[+] Use the command 'weaponavail' to see the list of weapons available"
        messageNotification(chatMessage)
        return
    end

    local input = table.concat(args, " ")
    input = input:lower()  -- Convert the input to lowercase for case-insensitive matching

    local foundWeapon = false
    SettingsChaos.Autopick = true

    for _, weapon in pairs(game:GetService("ReplicatedStorage").Weapons:GetChildren()) do
        if string.lower(weapon.Name):match(input) then
            foundWeapon = true

            local args = {
                [1] = weapon.Name
            }
            
            game:GetService("Players").LocalPlayer.PlayerGui["Menu Screen"].RemoteEvent:FireServer(unpack(args))
            game:GetService("Players").LocalPlayer.PlayerGui["Menu Screen"].Enabled = false

            local chatMessage = "[+] Autopicking: " .. weapon.Name
            messageNotification(chatMessage)
            break
        end
    end

    if not foundWeapon and not isValidWeapon(input) then
        local chatMessage = "[+] The desired weapon ('" .. input .. "') was not found or does not exist"
        messageNotification(chatMessage)
    end

    game.Players.LocalPlayer.PlayerGui.ChildAdded:Connect(function(child)
        if SettingsChaos.Autopick and child.Name == "Menu Screen" then
            local input = table.concat(args, " ") -- You need to define 'args' here or change it to the desired value
            for _, weapon in pairs(game:GetService("ReplicatedStorage").Weapons:GetChildren()) do
                if string.lower(weapon.Name):match(string.lower(input)) then
                    local args = {
                        [1] = weapon.Name
                    }
                    local menuScreen = game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("Menu Screen")
                    if menuScreen then
                        menuScreen.RemoteEvent:FireServer(unpack(args))
                    else
                        local chatMessage = "[+] Menu Screen not found in PlayerGui. Autopick failed"
                        messageNotification(chatMessage)
                    end
                end
            end
            local menuScreen = game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("Menu Screen")
            if menuScreen then
                menuScreen.Enabled = false
            else
                local chatMessage = "[+] Menu Screen not found in PlayerGui. Autopick failed"
                messageNotification(chatMessage)
            end
        end
    end)    
end)

cmd.add({"unautopick", "unap"}, {"unautopick (unap)", "Stops autopicking specified weapon"}, function()
    if not SettingsChaos.Autopick then
        local chatMessage = "[+] Autopick isn't on yet. Use autopick/ap <weaponname> to enable autopick"
        messageNotification(chatMessage)
    else
        local chatMessage = "[+] Autopick is disabled"
        messageNotification(chatMessage)
        SettingsChaos.Autopick = false
    end
end)


cmd.add({"setprefix", "prefix", "setpx", "px"}, {"setprefix/prefix <prefix>", "Changes the prefix of Cilberion Admin"}, function(...)
    PrefixChange = (...)
    args = {...}

    if #args == 0 then
        local chatMessage =  "[+] Invalid command format. Use setprefix/prefix (prefix)"
        messageNotification(chatMessage)
    elseif PrefixChange == "p" or PrefixChange == "[" or PrefixChange == "P" then
        local chatMessage = "[+] 'P', 'p' and '[' are not allowed as prefix\n\n[+] The following prefixes breaks the changing prefix command"
        messageNotification(chatMessage)
    else
        opt.prefix = PrefixChange
        local chatMessage = "[+] Prefix set to " .. PrefixChange .. ""
        messageNotification(chatMessage)
    end
end)


cmd.add({"loopflingall", "lpflall"}, {"loopflingall", "Loop flings all players in the server"}, function()
    if SettingsUni.Loopflingall then
        local chatMessage = "[+] Loopflingall is already active."
        messageNotification(chatMessage)
        return
    end

    SettingsUni.Loopflingall = true

    local Players = game:GetService("Players")

    local function LoopFlingAll()
        while SettingsUni.Loopflingall do
            local AllPlayers = Players:GetPlayers()

            for _, player in ipairs(AllPlayers) do
                SkidFling(player)
            end

            wait(1) -- Adjust the interval as needed
        end
    end

    local loopFlingThread = coroutine.create(LoopFlingAll)
    coroutine.resume(loopFlingThread)

    local chatMessageStart = "[+] Loopflingall has been enabled"
    messageNotification(chatMessageStart)
end)

cmd.add({"unloopflingall", "unlpflall"}, {"unloopflingall", "Stop looping flingall"}, function()
    if not SettingsUni.Loopflingall then
        local chatMessage = "[+] Loopflingall isn't on yet. Use unloopflingall to enable loopfling"
        messageNotification(chatMessage)
        return
    end

    SettingsUni.Loopflingall = false

    local chatMessageStop = "[+] Loopflingall has stopped"
    messageNotification(chatMessageStop)
end)

local function GetChar()
    local Player = game.Players.LocalPlayer
    local Char = Player.Character or Player.CharacterAdded:Wait()
    return Char
end

if not _G.IgnoreList then
    _G.IgnoreList = {}
end

cmd.add({"killall", "klall"}, {"killall", "Kills all players in the server"}, function()
    local chatMessage = "[+] Kill all has been executed"
    messageNotification(chatMessage)

    local playersToKill = {}

    -- Populate the playersToKill table with all players (except the local player)
    for _, player in pairs(game.Players:GetPlayers()) do
        if player ~= game.Players.LocalPlayer then
            table.insert(playersToKill, player)
        end
    end

    while #playersToKill > 0 do
        for _, v in pairs(game.Players.LocalPlayer.Backpack:GetChildren()) do
            if v:FindFirstChild("DamageRemote") then
                local targ
                local range = 99999999999999999999999

                for i, player in ipairs(playersToKill) do
                    local targetPlayer = player
                    local vhum = targetPlayer.Character:FindFirstChild("Humanoid")
                    local vroot = targetPlayer.Character:FindFirstChild("HumanoidRootPart")

                    if vhum and vroot and vhum.Health > 0 then
                        local dist = (vroot.Position - game.Players.LocalPlayer.Character.HumanoidRootPart.Position).magnitude

                        if not targetPlayer.Character:FindFirstChild("ForceField") and dist <= range then
                            targ = vhum
                            range = dist
                        end
                    end

                    if targ then
                        GetChar().Humanoid:EquipTool(v)
                        v.DamageRemote:FireServer(targ)
                        
                        -- Introduce a delay by waiting for two consecutive heartbeats
                        for i = 1, 2 do
                            game:GetService("RunService").Heartbeat:Wait()
                        end
                    end

                    if vhum.Health <= 0 then
                        table.remove(playersToKill, i)
                    end
                end
            end
        end
        task.wait() -- Add a delay between each cycle (0.2 seconds in this example)
    end

    local chatMessage = "[+] Kill all has been completed"
    messageNotification(chatMessage)
    game.Players.LocalPlayer.Character.Humanoid:UnequipTools()
end)



cmd.add({"loopkillall", "lpklall"}, {"lpkillall (lpklall)", "Loop kills all the player in the server"}, function()
    local chatMessage = "[+] Loop kill all has been enabled"
    messageNotification(chatMessage)

    SettingsChaos.Loopkillall = true
        repeat
            for i, v in pairs(game.Players.LocalPlayer.Backpack:GetChildren()) do
                if v:FindFirstChild("DamageRemote") then
                    GetChar().Humanoid:EquipTool(v)

                    local targ
                    local range = 99999999999999999999999
                    for i, v in pairs(workspace:GetChildren()) do
                        if v ~= GetChar() and not table.find(_G.IgnoreList, v.Name) then
                            local vhum = v:FindFirstChild("Humanoid")
                            local vroot = v:FindFirstChild("HumanoidRootPart")
                            if vhum and vroot then
                                local dist = (vroot.Position - game.Players.LocalPlayer.Character.HumanoidRootPart.Position).magnitude
                                if vhum.Health > 0 and not v:FindFirstChild("ForceField") and dist <= range then
                                    targ = vhum
                                    range = dist
                                end
                            end
                        end
                    end

                    for i = 1, 2 do
                        game:GetService("RunService").Heartbeat:Wait()
                    end

                    if targ then
                        v.DamageRemote:FireServer(targ)
                    end

                    if not SettingsChaos.Loopkillall then
                        break
                    end
                end
            end
        wait()
    until not SettingsChaos.Loopkillall
end)

cmd.add({"unloopkillall", "unlpklall", "ulka"}, {"unloopkillall (unlpklall)", "Stops loop killing all the players"}, function(...)
    if SettingsChaos.Loopkillall then
        SettingsChaos.Loopkillall = false
        local chatMessage = "[+] Loopkill all has been disabled"
        messageNotification(chatMessage)      
    else
        local chatMessage = "[+] LoopKill all is not active, use 'loopkillall/lpklall' to enable it"
        messageNotification(chatMessage)      
    end
end)

cmd.add({"whitelistkilladd", "wkadd"}, {"whitelistkilladd <player>", "Add a player to the whitelist for killall"}, function(...)
    local args = {...}
    
    if #args < 1 then
        local chatMessage = "[+] Invalid command format. Use whitelistkilladd/wkadd (username) to add a player to the whitelist for killall."
        messageNotification(chatMessage)
        return
	end

	Username = (...)
	local playerToAdd = getPlr(Username)

    if playerToAdd then
        if not table.find(_G.IgnoreList, playerToAdd.Name) then
            -- Add the player to the whitelist
            table.insert(_G.IgnoreList, playerToAdd.Name)
            local chatMessage = "[+] Added " .. playerToAdd.Name .. " to the whitelist for killall."
            messageNotification(chatMessage)
        else
            local chatMessage = "[+] " .. playerToAdd.Name .. " is already on the whitelist for killall."
            messageNotification(chatMessage)
        end
    else
        local chatMessage = "[+] Player not found. Make sure you entered a valid partial player name or display name."
        messageNotification(chatMessage)
    end
end)

cmd.add({"whitelistkillremove", "wkremove"}, {"whitelistkillremove <player>", "Remove a player from the whitelist for killall"}, function(...)
    local args = {...}
    
    if #args < 1 then
        local chatMessage = "[+] Invalid command format. Use whitelistkillremove/wkremove (username) to remove a player from the whitelist for killall."
        messageNotification(chatMessage)
        return
	end

	Username = (...)
	local playerToRemove = getPlr(Username)

    if playerToRemove then
        if table.find(_G.IgnoreList, playerToRemove.Name) then
            -- Remove the player from the whitelist
            table.remove(_G.IgnoreList, table.find(_G.IgnoreList, playerToRemove.Name))
            local chatMessage = "[+] Removed " .. playerToRemove.Name .. " from the whitelist for killall."
            messageNotification(chatMessage)
        else
            local chatMessage = "[+] " .. playerToRemove.Name .. " is not on the whitelist for killall."
            messageNotification(chatMessage)
        end
    else
        local chatMessage = "[+] Player not found. Make sure you entered a valid partial player name or display name."
        messageNotification(chatMessage)
    end
end)


cmd.add({"kill", "kl", "begone", "die"}, {"kill <username>", "Kills the given player"}, function(...)
    local args = {...}
    local searchLetters = table.concat(args, " ")

    if #args == 0 then
        local chatMessage = "[+] Invalid command format. Use kill/kl (username)"
        messageNotification(chatMessage)
        return
    end

    -- Check if the username is less than 2 characters
    if #args[1] < 2 then
        namerequiredNotification()
        return
    end


    local foundPlayers = {}
    for _, otherPlayer in pairs(game.Players:GetPlayers()) do
        local playerName = otherPlayer.Name
        local playerDisplayName = otherPlayer.DisplayName
        if string.find(playerName:lower(), searchLetters:lower()) or
           string.find(playerDisplayName:lower(), searchLetters:lower()) then
            table.insert(foundPlayers, otherPlayer)
        end
    end

    if #foundPlayers > 0 then
        if #game.Players.LocalPlayer.Backpack:GetChildren() == 0 then
            for _, weapon in pairs(game:GetService("ReplicatedStorage").Weapons:GetChildren()) do
                if string.lower(weapon.Name):match(input) then
                    foundWeapon = true
        
                    local args = {
                        [1] = "Pencil"
                    }
                    
                    game:GetService("Players").LocalPlayer.PlayerGui["Menu Screen"].RemoteEvent:FireServer(unpack(args))
                    game:GetService("Players").LocalPlayer.PlayerGui["Menu Screen"].Enabled = false
        
                    local chatMessage = "[+] Autopicking: " .. weapon.Name
                    messageNotification(chatMessage)
                    break
                end
            end
        else
            equipWeapons(game.Players.LocalPlayer)

            local tool = game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool")
            local damageRemote = tool and tool:FindFirstChild("DamageRemote")

            local playerNames = {}
            local playerDisplayNames = {}
            for _, foundPlayer in ipairs(foundPlayers) do
                table.insert(playerNames, foundPlayer.Name)
                table.insert(playerDisplayNames, foundPlayer.DisplayName)
            end

            if damageRemote then
                for i, foundPlayer in ipairs(foundPlayers) do
                    -- Check if the targetPlayer is not the local player
                    if foundPlayer ~= game.Players.LocalPlayer then
                        local targetHumanoid = foundPlayer.Character:FindFirstChild("Humanoid")
                        if targetHumanoid then
                            while targetHumanoid.Health > 0 do
                                local args = {
                                    [1] = targetHumanoid
                                }

                                game:GetService("Players").LocalPlayer.Character[tool.Name].DamageRemote:FireServer(unpack(args))
                                task.wait()
                            end

                            -- Unequip the tool from the target player's character
                            tool.Parent = game.Players.LocalPlayer.Backpack

                            local namesList = table.concat(playerNames, ", ")
                            local displayNamesList = table.concat(playerDisplayNames, ", ")
                            local chatMessage = "[+] Killed: " .. namesList .. " (" .. displayNamesList .. ")"
                            onlyoneNotification(chatMessage)
                        end
                    else
                        local chatMessage = "[+] You cannot kill " .. foundPlayer.Name .. " (" .. foundPlayer.DisplayName .. ")"
                        onlyoneNotification(chatMessage)
                    end
                end
            else
                local chatMessage = "[+] No matching username or display name found"
                messageNotification(chatMessage)
            end
        end
    end
end)


cmd.add({"fling", "fl"}, {"fling <username>", "Flings the given player"}, function(plr)

	local Targets = {plr}

	
	    -- Check if there are no arguments
    if #Targets == 0 then
        local chatMessage = "[+] Invalid command format. Use fling/fl (username)"
        messageNotification(chatMessage)
        return
    end

    -- Check if the username is less than 2 characters
    if #Targets[1] < 2 then
        namerequiredNotification()
        return
    end


        if Targets[1] then
            for _,x in next, Targets do
                GetPlayer(x)
            end
        else
            return
        end

        if AllBool then
            for _,x in next, Players:GetPlayers() do
                SkidFling(x)
            end
        end

        local foundPlayers = {}  -- To store found players
        for _,x in next, Targets do
            local targetPlayer = GetPlayer(x)
            if targetPlayer and targetPlayer ~= Player then
                table.insert(foundPlayers, targetPlayer)
            end
        end

        if #foundPlayers == 0 then
            local chatMessage = "[+] No matching username or display name found"
            messageNotification(chatMessage)
        else
        for _, TPlayer in ipairs(foundPlayers) do
            local chatMessage = "[+] Flinging: ".. TPlayer.Name .." (".. TPlayer.DisplayName ..")"
            messageNotification(chatMessage)
            SkidFling(TPlayer)
            local chatMessage = "[+] Flinging is complete for: ".. TPlayer.Name .." (".. TPlayer.DisplayName ..")"
            messageNotification(chatMessage)
		end
	end
end)

cmd.add({"flingall", "flall"}, {"flingall", "Flings all players in the server"}, function()
    local Players = game:GetService("Players")
    local AllBool = true
    local Player = Players.LocalPlayer
    local AllPlayers = Players:GetPlayers()

    local chatMessageStart = "[+] Flinging all players has started."
    messageNotification(chatMessageStart)

    if AllBool then
        for _, player in ipairs(AllPlayers) do
            SkidFling(player)
        end
    end

    local chatMessage = "[+] Flinging all players is done."
    messageNotification(chatMessage)
end)


local function GetClosestPlayer(MaxDist)
    local ClosestPlayer
    
    pcall(function()
        for _, Player in pairs(game.Players:GetPlayers()) do
            if Player ~= game.Players.LocalPlayer then
                local distance = (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - Player.Character.HumanoidRootPart.Position).magnitude
                
                if distance <= MaxDist and Player.Character.Humanoid.Health > 0 and not Player.Character:FindFirstChildOfClass("ForceField") then
                    ClosestPlayer = Player
                end
            end
        end
    end)
    return ClosestPlayer
end

local function IsPlayerHave(Tool)
    if not Tool then return end
    local plr = game.Players.LocalPlayer
    if plr.Backpack:FindFirstChild(Tool) or plr.Character:FindFirstChild(Tool) then
        return true
    else
        return false
    end
end


local function WhatWeaponPlayerHave()
    for _,Weapon in pairs(game:GetService("ReplicatedStorage").Weapons:GetChildren()) do
        if IsPlayerHave(Weapon.Name) then
            return Weapon
        end
    
    end
end


function LoopKillPlayer(targetPlayer)
    while loopKillingPlayers[targetPlayer.UserId] and SettingsChaos.Loopkill do
        while not targetPlayer.Character or not targetPlayer.Character:FindFirstChild("Humanoid") or WhatWeaponPlayerHave() == nil do
            task.wait()
        end

        if game.Players.LocalPlayer.Character:FindFirstChild(WhatWeaponPlayerHave().Name) then
            local args = {
                [1] = targetPlayer.Character.Humanoid
            }
            
            game:GetService("Players").LocalPlayer.Character[WhatWeaponPlayerHave().Name].DamageRemote:FireServer(unpack(args))            
        elseif game.Players.LocalPlayer.Backpack:FindFirstChild(WhatWeaponPlayerHave().Name) then
            game.Players.LocalPlayer.Character.Humanoid:EquipTool(game.Players.LocalPlayer.Backpack[WhatWeaponPlayerHave().Name])
        end

        task.wait()
    end
end


local function GetClosestPlayer()
    local ClosestPlayer

    pcall(function()
        for _, Player in pairs(game.Players:GetPlayers()) do
            if Player ~= game.Players.LocalPlayer then
                local distance = (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - Player.Character.HumanoidRootPart.Position).magnitude

                if distance <= SettingsChaos.Killaura.Distance and Player.Character.Humanoid.Health > 0 and not Player.Character:FindFirstChildOfClass("ForceField") then
                    ClosestPlayer = Player
                end
            end
        end
    end)
    return ClosestPlayer
end

cmd.add({"killaura", "klau"}, {"killaura <distance>", "Killaura in a specified distance"}, function(distance)
    local parsedDistance = tonumber(distance)

    if not parsedDistance then
        local chatMessage = "[+] Invalid command format. Use killaura/klau (distance)"
        messageNotification(chatMessage)
        return
    end

    -- Check if the distance is less than 0
    if parsedDistance == 0 then
        local chatMessage = "[+] Invalid distance. Distance must be greater than 0"
        messageNotification(chatMessage)
        return
    end

    if parsedDistance and parsedDistance >= 0 then
        SettingsChaos.Killaura.Distance = parsedDistance
        SettingsChaos.Killaura.Active = true

        while SettingsChaos.Killaura.Active do
            while GetClosestPlayer() == nil or WhatWeaponPlayerHave() == nil do
                game.Players.LocalPlayer.Character.Humanoid:UnequipTools()
                task.wait()
            end
            if game.Players.LocalPlayer.Character:FindFirstChild(WhatWeaponPlayerHave().Name) then
                local args = {
                    [1] = GetClosestPlayer().Character.Humanoid
                }

                game:GetService("Players").LocalPlayer.Character[WhatWeaponPlayerHave().Name].DamageRemote:FireServer(unpack(args))
            elseif game.Players.LocalPlayer.Backpack:FindFirstChild(WhatWeaponPlayerHave().Name) then
                game.Players.LocalPlayer.Character.Humanoid:EquipTool(game.Players.LocalPlayer.Backpack[WhatWeaponPlayerHave().Name])
            end
            task.wait()
        end
    else
        local chatMessage = "[+] Invalid command format. Use killaura/klau (distance)"
        messageNotification(chatMessage)
    end
end)

cmd.add({"unkillaura", "unklau"}, {"unkillaura", "Stops killaura"}, function()
    if not SettingsChaos.Killaura.Active then
        local chatMessage = "[+] Killaura isn't on yet. Use killaura/klau (distance) to enable killaura"
        messageNotification(chatMessage)
    else
        SettingsChaos.Killaura.Active = false
        local chatMessage = "[+] Killaura has been disabled"
        messageNotification(chatMessage)
    end
end)


local function GetClosestPlayerFromOtherPlayer(ally, distance)
    local MaxDist = distance or SettingsChaos.Givekillaura.Distance
    local ClosestPlayer

    pcall(function()
        for _, Player in pairs(game.Players:GetPlayers()) do
            if Player ~= game.Players.LocalPlayer and Player ~= ally then
                local playerPosition = ally.Character and ally.Character:FindFirstChild("HumanoidRootPart") and ally.Character.HumanoidRootPart.Position
                local enemyPosition = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") and Player.Character.HumanoidRootPart.Position

                if playerPosition and enemyPosition then
                    local distance = (playerPosition - enemyPosition).magnitude

                    if distance <= MaxDist and Player.Character:FindFirstChild("Humanoid") and Player.Character.Humanoid.Health > 0 and not Player.Character:FindFirstChildOfClass("ForceField") then
                        ClosestPlayer = Player
                    end
                end
            end
        end
    end)
    return ClosestPlayer
end

local function DealDamageToClosestPlayer(Ally, distance)
    while SettingsChaos.Givekillaura.Active do
        if game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("Humanoid") then
            while GetClosestPlayerFromOtherPlayer(Ally, distance) == nil or WhatWeaponPlayerHave() == nil do
                game.Players.LocalPlayer.Character.Humanoid:UnequipTools()
                task.wait()
            end

            if not SettingsChaos.Givekillaura.Active then
                    print("exit the loop")
                break  -- Exit the loop immediately if GivedKillAura is set to false.
            end

            if game.Players.LocalPlayer.Character:FindFirstChild(WhatWeaponPlayerHave().Name) then
                local args = {
                    [1] = GetClosestPlayerFromOtherPlayer(Ally, distance).Character.Humanoid
                }

                game:GetService("Players").LocalPlayer.Character[WhatWeaponPlayerHave().Name].DamageRemote:FireServer(unpack(args))
            elseif game.Players.LocalPlayer.Backpack:FindFirstChild(WhatWeaponPlayerHave().Name) then
                game.Players.LocalPlayer.Character.Humanoid:EquipTool(game.Players.LocalPlayer.Backpack[WhatWeaponPlayerHave().Name])
            end
        end
        task.wait()
    end
end

local nameyes
local distanceyes

local function InitializeKillAura(playerName, distance)
    local Ally = GetPlayer(playerName)
    nameyes = playerName  -- Save the player name to a global variable
    distanceyes = tonumber(distance)  -- Save the distance to a global variable
    SettingsChaos.Givekillaura.Active = true
    DealDamageToClosestPlayer(Ally, tonumber(distance) or SettingsChaos.Givekillaura.Distance)
end

local function ResetCharacter()
    if SettingsChaos.Givekillaura.Active then
        SettingsChaos.Givekillaura.Active = false
        wait(0.5)
        InitializeKillAura(nameyes, distanceyes or SettingsChaos.Givekillaura.Distance)
    end
end

game:GetService("Players").LocalPlayer.CharacterAdded:Connect(function()
    ResetCharacter()
end)


cmd.add({"givekillaura", "gklau"}, {"givekillaura/gklau (username) [distance]", "Gives a specific player killaura"}, function(playerName, distance)
    if not playerName then
        local chatMessage = "[+] Invalid command format. Use givekillaura/gklau (username) [distance]"
        messageNotification(chatMessage)
        return
    end
    
    local targetPlayer = GetPlayer(playerName)
    local givenDistance = tonumber(distance) or 20  -- Default distance is 20 if not specified

    if givenDistance <= 0 then
        local chatMessage = "[+] Invalid distance. Distance must be greater than 0"
        messageNotification(chatMessage)
        return
    end

    SettingsChaos.Givekillaura.Active = true
    local chatMessage = "[+] You have given Givekillaura to " .. targetPlayer.DisplayName .. " with a distance of " .. givenDistance
    messageNotification(chatMessage)

    InitializeKillAura(playerName, givenDistance)
end)

cmd.add({"delgivekillaura", "dgklau"}, {"delgivekillaura/dgklau", "Disables killaura"}, function()
    if not SettingsChaos.Givekillaura.Active then
        local chatMessage = "[+] Givekillaura isn't on yet. Use givekillaura/gklau (username) to enable givekillaura"
        messageNotification(chatMessage)
    else
        SettingsChaos.Givekillaura.Active = false
        local chatMessage = "[+] Givekillaura has been disabled"
        messageNotification(chatMessage)
    end
end)

cmd.add({"loopkill", "lpkl"}, {"loopkill/lpkl (username)", "Loopkills the given username"}, function(...)
    local args = {...}

    if #args == 0 then
        local chatMessage = "[+] Invalid command format. Use loopkill/lpkl (username)"
        messageNotification(chatMessage)
        return
    end
    -- Check if the username is less than 2 characters
    if #args[1] < 2 then
        namerequiredNotification()
        return
    end

    local targetPlayerName = table.concat(args, " ")
    local targetPlayer = GetPlayer(targetPlayerName)

    if targetPlayer then
        -- Check if the targetPlayer is not the local player
        if targetPlayer ~= game.Players.LocalPlayer then
            SettingsChaos.Loopkill = true
            -- Add the target player to the loopKillingPlayers table
            loopKillingPlayers[targetPlayer.UserId] = true

            local chatMessage = "[+] Loop killing " .. targetPlayer.Name
            messageNotification(chatMessage)

            -- Start loop killing for the target player
            LoopKillPlayer(targetPlayer)
        else
            local chatMessage = "[+]  You cannot loop kill ".. player.Name.. ""
            messageNotification(chatMessage)
        end
    else
        local chatMessage = "[+]  No matching username or display name found"
        messageNotification(chatMessage)
    end
end)


cmd.add({"unloopkill", "unlpkl"}, {"unloopkill/unlpkl (username)", "Stops loopkilling the given player"}, function(...)
    local args = {...}
    local targetPlayerName = table.concat(args, " ")
    local targetPlayer = GetPlayer(targetPlayerName)

    if targetPlayer then
        SettingsChaos.Loopkill = false
        loopKillingPlayers[targetPlayer.UserId] = nil
        local chatMessage = "[+] Stopped loop killing " .. targetPlayer.Name
        messageNotification(chatMessage)
    else
        local chatMessage = "[+] No player found with the username '" .. targetPlayerName .. "'"
        messageNotification(chatMessage)
    end
end)


cmd.add({"loopkillcheck", "lpklch"}, {"loopkillcheck/lpklch", "Checks all the people who are in loopkill"}, function(...)
    local loopKillingPlayersList = {}
    
    for userId, _ in pairs(loopKillingPlayers) do
        local player = game.Players:GetPlayerByUserId(userId)
        if player then
            table.insert(loopKillingPlayersList, player.Name)
        end
    end

    if #loopKillingPlayersList > 0 then
        local chatMessage = "[+] Players in loopkill: " .. table.concat(loopKillingPlayersList, ", ")
        messageNotification(chatMessage)
    else
        local chatMessage = "[+] No players in loopkill"
        messageNotification(chatMessage)
    end
end)




local iycmd
local IYLOADED = false

cmd.add({"iy", "infiniteyield"}, {"iy <command>", "Just like a normal IY command"}, function(...)

    local args = {...}

    if #args == 0 then
        local chatMessage = "[+] Invalid command format. Use iy/infiniteyield (command)"
        messageNotification(chatMessage)
        return
    end

	if IYLOADED == false then
		local function copytable(tbl) local copy = {} for i,v in pairs(tbl) do copy[i] = v end return copy end
		local sandbox_env = copytable(getfenv())

		setmetatable(sandbox_env, {
			__index = function(self, i)
			if rawget(sandbox_env, i) then
				return rawget(sandbox_env, i)
			elseif getfenv()[i] then
				return getfenv()[i]
			end
		end})
			sandbox_env.game = nil
			iy, _ = game:HttpGet("https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source"):gsub("local Main", "Main"):gsub("Players.LocalPlayer.Chatted","Funny = Players.LocalPlayer.Chatted"):gsub("local lastMessage","notify = _G.notify\nlocal lastMessage")
			setfenv(loadstring(iy),sandbox_env)()
			iy_cmds_table = sandbox_env.CMDs
			iy_gui = sandbox_env.Main
			iy_chathandler = sandbox_env.Funny
			execCmd = sandbox_env.execCmd
			iy_gui:Destroy()
			pcall(function()
				iy_chathandler:Disconnect()
			end)
			IYLOADED = true
		end

	execCmd((...))
	local chatMessage = "[+] Execute IY command: ".. ... ..""
	messageNotification(chatMessage)
end)


cmd.addWHS({"whitelist", "whs"}, {"whitelist <username>", "Whitelist someone to allow them to use commands"}, function(...)
    local args = {...}
    if #args == 0 then
        local chatMessage = "[+] Invalid command format. Use whitelist/whs (username)"
        messageNotification(chatMessage)
        return
    end

    -- Check if the username is less than 2 characters
    if #args[1] < 2 then
        namerequiredNotification()
        return
    end

    local partialName = args[1]
    local Player = findPlayer(partialName)

    if Player then
        if not Admin[Player.UserId] then
            Admin[Player.UserId] = { Player = Player }
            ChatMessage("/w " .. Player.Name .. " [Cilberion Admin] You've got admin. Prefix: '" .. opt.prefix .. "'")
            wait(0.2)
            ChatMessage("/w " .. Player.Name .. " [Cilberion Admin Commands] kill, fling")
            local chatMessage = "[+] " .. Player.Name .. " has now been whitelisted to use commands"
            messageNotification(chatMessage)
        else
            local chatMessage = "[+] " .. Player.Name .. " is already whitelisted"
            messageNotification(chatMessage)
        end
    else
        local chatMessage = "[+] No matching username or display name found"
        messageNotification(chatMessage)
    end
end)

cmd.addWHS({"blacklist", "bls"}, {"blacklist <username>", "Removes someone from being admin"}, function(...)
    local args = {...}

    if #args == 0 then
        local chatMessage = "[+] Invalid command format. Use blacklist/bls (username)"
        messageNotification(chatMessage)
        return
    end
        -- Check if the username is less than 2 characters
        if #args[1] < 2 then
            namerequiredNotification()
            return
        end

    local partialName = args[1]
    local Player = findPlayer(partialName)

    if Player then
        if Admin[Player.UserId] then
            Admin[Player.UserId] = nil -- Remove the entry from the Admin table
            local chatMessage = "[+] " .. Player.Name .. " is no longer an admin"
            messageNotification(chatMessage)
        else
            local chatMessage = "[+] " .. Player.Name .. " is not whitelisted"
            messageNotification(chatMessage)
        end
    else
        local chatMessage = "[+] No matching username or display name found"
        messageNotification(chatMessage)
    end
end)


cmd.add({"credits", "madeby"}, {"credits", "Made by: Cilvania"}, function()
    local chatMessage = "[+] Made by: Cilvania\n[+] Contributors: Franz"
    messageNotification(chatMessage)
    wait(0.2)
    local chatMessage = "[+] Credits to 'Nameless Admin' for the UI and stuff"
    messageNotification(chatMessage)
    wait(0.2)
    local chatMessage = "[+] Youtube: @cilvania / cilvaniabrbu"
    messageNotification(chatMessage)
    wait(0.2)
    local chatMessage = "[+] Discord: "
    messageNotification(chatMessage)
end)



 --[[ GUI VARIABLES ]]--
local ScreenGui
 if not RunService:IsStudio() then
	 ScreenGui = game:GetObjects("rbxassetid://13510552309")[1]
 else
	 repeat wait() until player:FindFirstChild("AdminUI", true)
	 ScreenGui = player:FindFirstChild("AdminUI", true)
 end

local description = ScreenGui.Description
local cmdBar = ScreenGui.CmdBar
local centerBar = cmdBar.CenterBar
local cmdInput = centerBar.Input
local cmdAutofill = cmdBar.Autofill
local cmdExample = cmdAutofill.Cmd
local leftFill = cmdBar.LeftFill
local rightFill = cmdBar.RightFill
local chatLogsFrame = ScreenGui.ChatLogs
local chatLogs = chatLogsFrame.Container.Logs
local chatExample = chatLogs.TextLabel
local commandsFrame = ScreenGui.Commands
local commandsFilter = commandsFrame.Container.Filter
local commandsList = commandsFrame.Container.List
local commandExample = commandsList.TextLabel
local resizeFrame = ScreenGui.Resizeable
 local resizeXY = {
	 Top		= {Vector2.new(0, -1),	Vector2.new(0, -1),	"rbxassetid://2911850935"},
	 Bottom	= {Vector2.new(0, 1),	Vector2.new(0, 0),	"rbxassetid://2911850935"},
	 Left	= {Vector2.new(-1, 0),	Vector2.new(1, 0),	"rbxassetid://2911851464"},
	 Right	= {Vector2.new(1, 0),	Vector2.new(0, 0),	"rbxassetid://2911851464"},
	 
	 TopLeft		= {Vector2.new(-1, -1),	Vector2.new(1, -1),	"rbxassetid://2911852219"},
	 TopRight	= {Vector2.new(1, -1),	Vector2.new(0, -1),	"rbxassetid://2911851859"},
	 BottomLeft	= {Vector2.new(-1, 1),	Vector2.new(1, 0),	"rbxassetid://2911851859"},
	 BottomRight	= {Vector2.new(1, 1),	Vector2.new(0, 0),	"rbxassetid://2911852219"},
 }
 
 cmdExample.Parent = nil
 chatExample.Parent = nil
 commandExample.Parent = nil
 resizeFrame.Parent = nil
 
 local rPlayer = Players:FindFirstChildWhichIsA("Player")
 local coreGuiProtection = {}
 
 pcall(function()
	 for i, v in pairs(ScreenGui:GetDescendants()) do
		 coreGuiProtection[v] = rPlayer.Name
	 end
	 ScreenGui.DescendantAdded:Connect(function(v)
		 coreGuiProtection[v] = rPlayer.Name
	 end)
	 coreGuiProtection[ScreenGui] = rPlayer.Name
	  
	 local meta = getrawmetatable(game)
	 local tostr = meta.__tostring
	 setreadonly(meta, false)
	 meta.__tostring = newcclosure(function(t)
		 if coreGuiProtection[t] and not checkcaller() then
			 return coreGuiProtection[t]
		 end
		 return tostr(t)
	 end)
 end)

 if not RunService:IsStudio() then
	 local newGui = game:GetService("CoreGui"):FindFirstChildWhichIsA("ScreenGui")
	 newGui.DescendantAdded:Connect(function(v)
		 coreGuiProtection[v] = rPlayer.Name
	 end)
	 for i, v in pairs(ScreenGui:GetChildren()) do
		 v.Parent = newGui
	 end
	 ScreenGui = newGui
 end
 
 --[[ GUI FUNCTIONS ]]--
 gui = {}
 gui.txtSize = function(ui, x, y)
	 local textService = game:GetService("TextService")
	 return textService:GetTextSize(ui.Text, ui.TextSize, ui.Font, Vector2.new(x, y))
 end
 gui.commands = function()
	 if not commandsFrame.Visible then
		 commandsFrame.Visible = true
		 commandsList.CanvasSize = UDim2.new(0, 0, 0, 0)
	 end
	 for i, v in pairs(commandsList:GetChildren()) do
		 if v:IsA("TextLabel") then
			 Destroy(v)
		 end
	 end
	 local i = 0
	 for cmdName, tbl in pairs(Commands) do
		 local Cmd = commandExample:Clone()
		 Cmd.Parent = commandsList
		 Cmd.Name = cmdName
		 Cmd.Text = " " .. tbl[2][1]
		 Cmd.MouseEnter:Connect(function()
			 description.Visible = true
			 description.Text = tbl[2][2]
		 end)
		 Cmd.MouseLeave:Connect(function()
			 if description.Text == tbl[2][2] then
				 description.Visible = false
				 description.Text = ""
			 end
		 end)
		 i = i + 1
	 end
	 commandsList.CanvasSize = UDim2.new(0, 0, 0, i*20+10)
	 commandsFrame.Position = UDim2.new(0.5, -283/2, 0.5, -260/2)
 end
 gui.chatlogs = function()
	 if not chatLogsFrame.Visible then
		 chatLogsFrame.Visible = true
	 end
	 chatLogsFrame.Position = UDim2.new(0.5, -283/2+5, 0.5, -260/2+5)
 end
 
 gui.tween = function(obj, style, direction, duration, goal)
	 local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle[style], Enum.EasingDirection[direction])
	 local tween = TweenService:Create(obj, tweenInfo, goal)
	 tween:Play()
	 return tween
 end
 gui.mouseIn = function(guiObject, range)
	 local pos1, pos2 = guiObject.AbsolutePosition, guiObject.AbsolutePosition + guiObject.AbsoluteSize
	 local mX, mY = mouse.X, mouse.Y
	 if mX > pos1.X-range and mX < pos2.X+range and mY > pos1.Y-range and mY < pos2.Y+range then
		 return true
	 end
	 return false
 end
 gui.resizeable = function(ui, min, max)
	 local rgui = resizeFrame:Clone()
	 rgui.Parent = ui
	 
	 local mode
	 local UIPos
	 local lastSize
	 local lastPos = Vector2.new()
	 
	 local function update(delta)
		 local xy = resizeXY[(mode and mode.Name) or '']
		 if not mode or not xy then return end
		 local delta = (delta * xy[1]) or Vector2.new()
		 local newSize = Vector2.new(lastSize.X + delta.X, lastSize.Y + delta.Y)
		 newSize = Vector2.new(
			 math.clamp(newSize.X, min.X, max.X),
			 math.clamp(newSize.Y, min.Y, max.Y)
		 )
		 ui.Size = UDim2.new(0, newSize.X, 0, newSize.Y)
		 ui.Position = UDim2.new(
			 UIPos.X.Scale, 
			 UIPos.X.Offset + (-(newSize.X - lastSize.X) * xy[2]).X, 
			 UIPos.Y.Scale, 
			 UIPos.Y.Offset + (delta * xy[2]).Y
		 )
	 end
	 
	 mouse.Move:Connect(function()
		 update(Vector2.new(mouse.X, mouse.Y) - lastPos)
	 end)
	 
	 for _, button in pairs(rgui:GetChildren()) do
		 local isIn = false
		 button.InputBegan:Connect(function(input)
			 if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
				 mode = button
				 lastPos = Vector2.new(mouse.X, mouse.Y)
				 lastSize = ui.AbsoluteSize
				 UIPos = ui.Position
			 end
		 end)
		 button.InputEnded:Connect(function(input)
			 if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
				 mode = nil
			 end
		 end)
		 button.MouseEnter:Connect(function()
			 mouse.Icon = resizeXY[button.Name][3]
		 end)
		 button.MouseLeave:Connect(function()
			 if mouse.Icon == resizeXY[button.Name][3] then
				 mouse.Icon = ""
			 end
		 end)
	 end
 end
 gui.draggable = function(ui, dragui)
	 if not dragui then dragui = ui end
	 local UserInputService = game:GetService("UserInputService")
	 
	 local dragging
	 local dragInput
	 local dragStart
	 local startPos
	 
	 local function update(input)
		 local delta = input.Position - dragStart
		 ui.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
	 end
	 
	 dragui.InputBegan:Connect(function(input)
		 if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			 dragging = true
			 dragStart = input.Position
			 startPos = ui.Position
			 
			 input.Changed:Connect(function()
				 if input.UserInputState == Enum.UserInputState.End then
					 dragging = false
				 end
			 end)
		 end
	 end)
	 
	 dragui.InputChanged:Connect(function(input)
		 if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			 dragInput = input
		 end
	 end)
	 
	 UserInputService.InputChanged:Connect(function(input)
		 if input == dragInput and dragging then
			 update(input)
		 end
	 end)
 end
 gui.menuify = function(menu)
	 local exit = menu:FindFirstChild("Exit", true)
	 local mini = menu:FindFirstChild("Minimize", true)
	 local minimized = false
	 local sizeX, sizeY = Instance.new("IntValue", menu), Instance.new("IntValue", menu)
	 mini.MouseButton1Click:Connect(function()
		 minimized = not minimized
		 if minimized then
			 sizeX.Value = menu.Size.X.Offset
			 sizeY.Value = menu.Size.Y.Offset
			 gui.tween(menu, "Quart", "Out", 0.5, {Size = UDim2.new(0, 283, 0, 25)})
		 else
			 gui.tween(menu, "Quart", "Out", 0.5, {Size = UDim2.new(0, sizeX.Value, 0, sizeY.Value)})
		 end
	 end)
	 exit.MouseButton1Click:Connect(function()
		 menu.Visible = false
	 end)
	 gui.draggable(menu, menu.Topbar)
	 menu.Visible = false
 end


 gui.loadCommands = function()
	for i, v in pairs(cmdAutofill:GetChildren()) do
		if v.Name ~= "UIListLayout" then
			Destroy(v)
		end
	end
	local last = nil
	local i = 0
	for name, tbl in pairs(Commands) do
		local info = tbl[2]
		local btn = cmdExample:Clone()
		btn.Parent = cmdAutofill
		btn.Name = name
		btn.Input.Text = info[1]
		i = i + 1
		
		local size = btn.Size
		btn.Size = UDim2.new(0, 0, 0, 25)
		btn.Size = size
	end
end

	 gui.loadCommands()
  for i, v in ipairs(cmdAutofill:GetChildren()) do
		 if v:IsA("Frame") then
			 v.Visible = false
		 end
	 end
 gui.barSelect = function(speed)
	 centerBar.Visible = true
	 gui.tween(centerBar, "Sine", "Out", speed or 0.25, {Size = UDim2.new(0, 250, 1, 15)})
	 gui.tween(leftFill, "Quad", "Out", speed or 0.3, {Position = UDim2.new(0, 0, 0.5, 0)})
	 gui.tween(rightFill, "Quad", "Out", speed or 0.3, {Position = UDim2.new(1, 0, 0.5, 0)})
 end
 gui.barDeselect = function(speed)
	 gui.tween(centerBar, "Sine", "Out", speed or 0.25, {Size = UDim2.new(0, 250, 0, 0)})
	 gui.tween(leftFill, "Sine", "In", speed or 0.3, {Position = UDim2.new(-0.5, 100, 0.5, 0)})
	 gui.tween(rightFill, "Sine", "In", speed or 0.3, {Position = UDim2.new(1.5, -100, 0.5, 0)})
	 for i, v in ipairs(cmdAutofill:GetChildren()) do
		 if v:IsA("Frame") then
			 wrap(function()
				 wait(math.random(1, 200)/2000)
				 gui.tween(v, "Back", "In", 0.35, {Size = UDim2.new(0, 0, 0, 25)})
			 end)
		 end
	end
 end

 -- [[ AUTOFILL SEARCHER ]] --
 gui.searchCommands = function()
	local str = (cmdInput.Text:gsub(";", "")):lower()
	local index = 0
	local lastFrame
	for _, v in ipairs(cmdAutofill:GetChildren()) do
		if v:IsA("Frame") and index < 5 then
			local cmd = Commands[v.Name]
			local name = cmd and cmd[2][1] or ""
			v.Input.Text = str ~= "" and v.Name:find(str) == 1 and v.Name or name
			v.Visible = str == "" or v.Name:find(str)
			if v.Visible then
				index = index + 1
				local n = math.sqrt(index) * 125
				local yPos = (index - 1) * 28
				local newPos = UDim2.new(0.5, 0, 0, yPos)
				gui.tween(v, "Quint", "Out", 0.3, {
					Size = UDim2.new(0.5, n, 0, 25),
					Position = lastFrame and newPos or UDim2.new(0.5, 0, 0, yPos),
				})
				lastFrame = v
			end
		end
	end
end

 --[[ GUI FUNCTIONALITY ]]--

-- [[ OPEN THE COMMAND BAR ]] -- 
 mouse.KeyDown:Connect(function(k)
	 if k:lower() == opt.prefix then
		 gui.barSelect()
		 cmdInput.Text = ''
		 cmdInput:CaptureFocus()
				 wait(0.00005)
							 cmdInput.Text = ''
	 end
 end)

 -- [[ CLOSE THE COMMAND BAR ]] -- 
 cmdInput.FocusLost:Connect(function(enterPressed)
	 if enterPressed then
		 wrap(function()
			 lib.parseCommand(opt.prefix .. cmdInput.Text)
		 end)
	 end
	 gui.barDeselect()
	end)
 
 cmdInput.Changed:Connect(function(p)
	 if p ~= "Text" then return end
	 gui.searchCommands()
 end)
 
 gui.barDeselect(0)
 cmdBar.Visible = true
 gui.menuify(chatLogsFrame)
 gui.menuify(commandsFrame)
 
 -- [[ GUI RESIZE FUNCTION ]] -- 

-- table.find({Enum.Platform.IOS, Enum.Platform.Android}, game:GetService("UserInputService"):GetPlatform()) | searches if the player is on mobile.
 if table.find({Enum.Platform.IOS, Enum.Platform.Android}, game:GetService("UserInputService"):GetPlatform()) then 
 else
 gui.resizeable(chatLogsFrame, Vector2.new(173,58), Vector2.new(1000,1000))
 gui.resizeable(commandsFrame, Vector2.new(184,84), Vector2.new(1000,1000))
 end
 
 -- [[ CMDS COMMANDS SEARCH FUNCTION ]] --
 commandsFilter.Changed:Connect(function(p)
	 if p ~= "Text" then return end
	 for i, v in pairs(commandsList:GetChildren()) do
		 if v:IsA("TextLabel") then
			 if v.Name:find(commandsFilter.Text:lower()) and v.Name:find(commandsFilter.Text:lower()) <= 2 then
				 v.Visible = true
			 else
				 v.Visible = false
			 end
		 end
	 end
 end)
 
 -- [[ CHAT TO USE COMMANDS ]] --
 local function bindToChat(plr, msg)
	 local chatMsg = chatExample:Clone()
	 for i, v in pairs(chatLogs:GetChildren()) do
		 if v:IsA("TextLabel") then
			 v.LayoutOrder = v.LayoutOrder + 1
		 end
	 end
	 chatMsg.Parent = chatLogs
	 chatMsg.Text = ("[%s]: %s"):format(plr.Name, msg)
	 
	 local txtSize = gui.txtSize(chatMsg, chatMsg.AbsoluteSize.X, 100)
	 chatMsg.Size = UDim2.new(1, -5, 0, txtSize.Y)
 end
 
 for i, plr in pairs(Players:GetPlayers()) do
	 plr.Chatted:Connect(function(msg)
		 bindToChat(plr, msg)
	 end)
 end
 Players.PlayerAdded:Connect(function(plr)
	 plr.Chatted:Connect(function(msg)
		 bindToChat(plr, msg)
	 end)
 end)
 
 mouse.Move:Connect(function()
	 description.Position = UDim2.new(0, mouse.X, 0, mouse.Y)
	 local size = gui.txtSize(description, 200, 100)
	 description.Size = UDim2.new(0, size.X, 0, size.Y)
 end)
 
 RunService.Stepped:Connect(function()
	 chatLogs.CanvasSize = UDim2.new(0, 0, 0, chatLogs.UIListLayout.AbsoluteContentSize.Y)
	 commandsList.CanvasSize = UDim2.new(0, 0, 0, commandsList.UIListLayout.AbsoluteContentSize.Y)
 end)
 
 --cilberion admin command print
 loadstring(game:HttpGet("https://pastebin.com/raw/pwgUrJMi"))();
 
 -- never used this lol
 function Destroy(guiObject)
	 if not pcall(function()guiObject.Parent = game:GetService("CoreGui")end) then
		 guiObject.Parent = nil
	 end
 end
 
 wait(0.2)
 
 -- [[ COMMAND BAR BUTTON ]] --
 local ScreenGui = Instance.new("ScreenGui")
 local TextClickButton = Instance.new("TextButton")
 local UICorner = Instance.new("UICorner")
 
 ScreenGui.Parent = game.CoreGui
 ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
 ScreenGui.ResetOnSpawn = true
 
 TextClickButton.Name = "CilberionAdminButton"
 TextClickButton.Parent = ScreenGui
 TextClickButton.BackgroundColor3 = Color3.fromRGB(4, 4, 4)
 TextClickButton.BackgroundTransparency = 1.000
 TextClickButton.Position = UDim2.new(0.418, 0,0, 0)
 TextClickButton.Size = UDim2.new(0, 2, 0, 33)
 TextClickButton.Font = Enum.Font.SourceSansBold
 TextClickButton.Text = "Cilberion Admin " .. currentversion .. ""
 TextClickButton.TextColor3 = Color3.fromRGB(255, 255, 255)
 TextClickButton.TextSize = 20.000
 TextClickButton.TextWrapped = true
 
 UICorner.CornerRadius = UDim.new(1, 0)
 UICorner.Parent = TextClickButton
 
 local function PZORYLB_fake_script() -- TextClickButton.LocalScript 
	 local script = Instance.new('LocalScript', TextClickButton)
	 textclickbutton = script.Parent
	 textclickbutton.Size = UDim2.new(0, 2,0, 33)
	 textclickbutton.BackgroundTransparency = 0.14
	 textclickbutton:TweenSize(UDim2.new(0, 251,0, 33), "Out", "Quint",1,true)
	 wait(2)
	 textclickbutton:TweenSize(UDim2.new(0, 32, 0, 33), "Out", "Quint",1,true)
	 textclickbutton:TweenPosition(UDim2.new(0.48909232, 0, 0, 0), "Out", "Quint",1,true)
	 wait(0.4)
	 textclickbutton.Text = "CA"
	 textclickbutton.Active = true
 gui.draggable(textclickbutton)
 end
 coroutine.wrap(PZORYLB_fake_script)()
 
 TextClickButton.MouseButton1Click:Connect(function()
	 gui.barSelect()
		 cmdInput.Text = ''
		 cmdInput:CaptureFocus()
 end)

 --[[
	End of the source code.
	Join the discord for updates or give command ideas, that could be added.
	https://discord.gg/ACk4JyVJ6x
--]]
